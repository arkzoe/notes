# 封装
```c#
<access specifier> class  class_name 
{
    // member variables
    <access specifier> <data type> variable1;
    <access specifier> <data type> variable2;
    ...
    <access specifier> <data type> variableN;
    // member methods
    <access specifier> <return type> method1(parameter_list) 
    {
        // method body 
    }
    <access specifier> <return type> method2(parameter_list) 
    {
        // method body 
    }
    ...
    <access specifier> <return type> methodN(parameter_list) 
    {
        // method body 
    }
}
```
### 属性
- get外界需要读数据时，返回数据给调用方
- set外界对变量赋值调用
	- 加private内部调用
	- 不能两个都有访问修饰符
	- get，set可以只有一个
	- 保护成员属性
- 自动属性
	- 没有小写字段储存，自动声明一个空间存储
```
	public int HP{
		get;
		set;
	}
```
- 构造函数特殊写法
	- 访问修饰符 构造函数名(参数列表):this(参数1，)
### 对象的生命周期
- 垃圾回收机制
	- CLR内存管理机制，会有效的释放内存
	- GC.Collect();//有多种算法--Loading
	- 分代每代满了回收
- 构造->使用->析构
## 索引器
```c#
访问修饰符 返回值 this[参数类型 参数名，参数类型 参数名]
{
	写法规则和属性相同
	get{}
	set{}
}
```
- 让对象像数组一样通过索引访问类内数组
- 重载
## 静态成员
- static
- 静态函数中不能直接使用非静态成员
- 静态变量
	- 唯一变量
	- 方便别人获取对象声明
- 静态方法
	- 常用唯一方法的声明
- 常量必须初始化，只能修饰变量，写在访问修饰符后
## 静态类静态构造函数
### 静态类
- 只能包含静态成员
- 不能被实例化
- 工具类
### 静态构造函数
- 不能使用访问修饰符
- 不能有参数
- 只会自动调用一次
## 拓展方法
- 为非静态变量类型添加新方法
- 一定是静态类中
- 一定是一个静态函数
- 第一个参数为拓展目标
- 第一个参数用this修饰
- 拓展名和原有方法重名调用原有方法
```c#
访问修饰符 static 返回值 函数名(this 拓展类型 参数名，参数类型 参数名)
static class Tools{
	public static void xxx(this int v){
		//
	}
}
```
## 运算符重载
- 一定是公共静态方法
- 返回值写operator前
- 逻辑自定义
- 条件运算符要成对实现
- 一个符号可以多个重载
- 不能使用ref和out
```c#
public static 返回类型 operator 运算符(参数)
```
- 可重载
	- 算数
	- 逻辑
	- 位
	- 条件
- 不可重载
	- 逻辑与/或
	- 索引[]
	- 强转运算符()
	- 特殊运算符
	- 点、三目、赋值
## 内部类和分部类
### 内部类
- 在一个类中声明一个类、
- 使用时要用包裹者点出
- 作用：亲密关系变现
- 注：访问修饰符作用大
### 分布类
- 把一个类分成几部分声明
- 关键字：partial
- 作用：分布描述一个类，增加程序拓展性
- 注：
	- 可以写在多个脚本文件中
	- 访问修饰符要一致
	- 不能有重复成员
#### 分部方法
- 将方法的声明实现分离
- 不能加访问修饰符 默认私有
- 只能在分布类中声明
- 返回值只能是void
- 可以有参但不用out关键字
# 继承
- 单根性：子类只能有一个父类
- 传递性：子类可以继承父类的父类
```c#
class 类名:被继承的类{

}
```
## 里氏替换原则
- 任何父类出现的地方，子类都可以代替
- 父类容器装载子类对象
- is
	- 判断一个对象是否是指定类对象
	- 返回bool
- as
	- 将一个对象转换成指定类对象
	- 返回指定类型
	- 失败返回null
## 继承中的构造函数
- 先父类
- 用base，代表父类，调用父类构造函数
- 父类无参很重要，子类实例化默认调用父类无参构造
- base指定调用
## Object和装箱拆箱
- object--类
	- 用object装所有对象
	- 表示不确定类型。作为函数传参类型
	- is as判断转换
```c#
object str = "";
string s = str.ToString();
string s = str as string;

object arr = new int[10];
int[] arr = arr as int[];
int[] arr = (int[])arr;
```
- 装箱拆箱
- 用object存值类型--装
	- 值类型用引用存储
	- 栈内存迁移到堆内存中
- 把object转为值类型--拆
	- 把引用类型存储的值类型取出
	- 堆内存会迁移到栈内存中
- 优：不确定类型方便存储传递
- 缺：增加性能消耗
## 密封类--final
- 用sealed修饰
- 让类无法再被继承
# 多态
- 继承同一父类的子类在执行相同方法时有不同的表现
- 让同一对象有唯一行为特征
- 编译时多态--函数重载
- 运行时多态（vob、抽象函数、接口）
## Vob
- virtual--虚函数
	- 可选择是否写逻辑
- override--重写
- base--父类，可以保留父类行为
## 抽象类和抽象方法
- abstract修饰的类
	- 不能实例化
	- 包含实例方法
	- 继承必须重写抽象方法
- abstract修饰的方法
	- 只能在抽象类中声明
	- 没有方法体
	- 不能私有
	- 继承后必须实现，override重写
## 接口
- 行为的抽象规范
- interface
	- 不包含成员变量
	- 只包含方法、属性、索引器、事件
	- 成员不能被实现
	- 成员不能是私有
	- 不能继承类，能继承另一个接口
- 规范
	- 命名：帕斯卡前面加个I
	- 类能继承多个接口
	- 继承后，必须实现接口中所有成员，必须public
	- 实现的接口函数，可以加virtual子类中重写
- 特点
	- 与类的声明类似
	- 用于继承
	- 不能实例化，可以做容器存储对象
- 显式实现接口
	- 继承多个接口，存在同名方法
	- 接口名.行为
- 继承类
	- 对象间继承，包括行为特征
- 继承接口
	- 行为间继承，继承接口的行为规范
## 密封函数
- sealed修饰的重写函数
	- 让虚函数或抽象方法之后不能被重写
	- 和override一起出现
# 关联知识点
## 命名空间
- 组织重用代码
```C#
namespace 命名空间名称{
	类
}
```
- 不同命名空间中互相使用，需引用命名空间或指明出处
	- using xxx
	- xxx.
- 不同命名空间中允许有同名类
## Object
- 静态
	- Equals判断两个对象是否相等
	- 判断权交给左侧对象
	- 不管类型按左侧对象Equals方法规则比较
	- ReferenceEquals
	- 比较两个对象是否是相同的引用，比较引用类型的对象
	- 值类型返回值false
- 成员
	- GetType
	- 获取对象运行时的类型
	- MenberwiseClone
	- 获取对象的浅拷贝对象
	- 新对象的引用变量和老对象一致
- 虚
	- Equals
	- 相当于ReferenceEquals
	- 可以自定义
	- GeetHashCode
	- 获取对象哈希值
	- ToString
	- 返回当前对象代表的字符串
	- 自定义对象转字符串规则
	- 常用
## String
- 字符串指定位置获取：ToCharArray
- 字符串拼接：Format
- 正向查找字符位置：IndexOf
- 反向查找指定字符串位置：LastIndexOf
- 移除指定位置后的字符：Remove 
- 替换指定字符串：Replace
- 大小写转换：ToUpper，ToLower
- 字符串截取：Substring
- 字符串切割：Split
## StringBuilder
- 需引用命名空间
- 修改字符串不创建新对象，修改拼接字符串使用
- 容量，自动扩容：Capacity
- 长度：Length
- 增：Append，AppendFormat
- 插入：Insert
- 删：Remove
- 清空：Clear
- 查：[]
- 改：=
- 替换：Replace
## 结构体和类
- 存储空间：结构体是值，类是引用
- 结构体具备封装特性，无继承多态
- 细节区别
	1. 结构体是值类型，类是引用类型
	2. 结构体存在栈中，类存在堆中
	3. 结构体成员不能使用protected访问修饰符，而类可以
	4. 结构体成员变量申明不能指定初始值，而类可以
	5. 构体不能申明无参的构造函数，而类可以
	6. 结构体申明有参构造函数后，无参构造不会被顶掉
	7. 结构体不能申明析构函数，而类可以
	8. 结构体不能被继承，而类可以
	9. 结构体需要在构造函数中初始化所有成员变量，而类随意
	10. 结构体不能被静态static修饰（不存在静态结构体），而类可以
	11. 结构体不能在自己内部申明和自已一样的结构体变量，而类可以
- 结构体可以继承接口
- 如何选择结构体和类
	1. 想要用继承和多态时，直接淘汰结构体，比如玩家、怪物等等
	2. 对象时数据集合时，优先考虑结构体，比如位置、坐标等等
	3. 从值类型和引用类型赋值时的区别上去考虑，比如经常被赋值传递的对象，并且改变赋值对象，原对象不想跟着变化时，就用结构体。比如坐标、向量、旋转等等
## 抽象类和接口
- 相同点
	1. 都可以被继承
	2. 都不能直接实例化
	3. 都可以包含方法申明
	4. 子类必须实现未实现的方法
	5. 都遵循里氏替换原则
- 区别
	1. 抽象类中可以有构造函数；接口中不能
	2. 抽象类只能被单一继承；接口可以被继承多个
	3. 抽象类中可以有成员变量；接口中不能
	4. 抽象类中可以申明成员方法，虚方法，抽象方法，静态方法；接口中只能申明没有实现的抽象方法
	5. 抽象类方法可以使用访问修饰符；接口中建议不写，默认public
- 如何选择
- 表示对象的用抽象类，表示行为拓展的用接口
- 不同对象拥有的共同行为，我们往往可以使用接口来实现