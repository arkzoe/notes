# 简单数据结构
## ArrayList
- object类型的数组
- Add，AddRange，Insert
- Remove，RemoveAt
- Clear
- 查：[]：指定位置，Contains：是否存在
- IndexOf，LastIndexOf：返回从头开始索引
- =
- 遍历：Count获取长度，foreach遍历，Capacity
- 少用
## Stack
- object类型的数组
- Push
- Pop
- Peek，Contains：是否存在
- Clear
- Count，foreach遍历/转成数组
## Queue
- Enqueue
- Dequeue
- Peek，Contains：是否存在
- Clear
- Count，foreach遍历/转成数组
## Hashtable
- Add
- Remove
- Clear
- []
- Contains，三种
- 遍历
	- 键：foreach(object item in hashtable.Keys)
	- 值：foreach(object item in hashtable.Values)
	- 键值对：foreach(DictionaryEntry item in hashtable)
	- 迭代器
```c#
IDictionaryEnumerator myE = hashtable.GetEnumerator();
bool flag = myE.MoveNext();
while(flag){
	writeline
	flag = myE.MoveNext();
}
```
# 泛型
- 泛型类和泛型接口
```c#
class 类名<T>
interface 接口名<T>
```
- 泛型方法
```c#
函数名 <T>(参数)
```
## 泛型约束
- 类型有限制
- where
```c#
//值类型                       where T :struct
//引用类型                     where T :class
//存在无参公共构造参数          where T :new()
//某个类本身或派生类            where T :类名
//某个接口的派生类              where T :接口名
//另一个泛型类本身或派生类型     where T :另一个泛型字母
```
- 组合使用
- 多个泛型有约束
# 泛型数据结构
- List--ArrayList
- Dictionary--HashTable
- LinkedList--双向链表
	- AddLast,AddFirst
	- RemoveFirst,RemoveLast,Remove,Clear
	- First,Last
	- Find
	- Contains
	- Next,Previous
- Stack/Queue
# 委托事件
## 委托--函数指针
- 定义函数的变量类型
- 函数容器
- delegate
```c#
访问修饰符 delegate 返回值 委托名(参数);
public delegate void xx();
xx x = new x(ss);
x.Invoke();
xx x = ss;
x();
```
- 作为类的成员
- 作为函数传参--先处理别的再执行函数
- 委托变量能存储多个函数
```c#
xx x = f;
x += f;//执行两次f
```
- 系统定义的
	- Action
	- Func《》指定返回值，传参
	- Action《》最多16个参数
## 事件
```c#
访问修饰符 event 委托类型 事件名;
```
- 成员变量存在类中
- 不在类外赋值、调用，可以加减
- 只能作为成员存在于类、接口、结构体中
- 使用与委托一样
- 防止外部随意置空、调用委托
- 相当于对委托进行封装
## 匿名函数
```c#
delegate(参数){

};
//无参无返回值
Action a = delegate(){
};
//有参
Action a = delegate(参){
};
//有返回值
Action a = delegate(){
	return;
};
//作为参数传递/返回值

```
- 函数中传递委托参数
- 委托或事件赋值时
- 脱离委托事件，不会使用
- 缺
	- 添加到委托事件后，无法单独移除
## Lambda
- 匿名函数简写
```c#
(参数)=>{}
```
- 闭包：匿名函数体中如果使用了外部函数的变量，那么就会把这个变量拷贝到堆上，所以在外部函数执行完毕后还能使用，变量是最终值
# list排序
- 自带--sort
- 自定义--compareto
- 委托排序--sort传函数
# 协变逆变
- 协变--子类变父类：和谐自然的变化
- 逆变--父类变子类
- 修饰泛型字母
	- 协变：out
	- 逆变：in
- 用于泛型中修饰泛型字母
1. 用out修饰的泛型只能作为返回值，in修饰只能作为参数
# 多线程
- Thread
```c#
//1.声明线程
//线程执行代码需封装到函数中
Thread t = new Thread(xxx);
//2.启动
t.Start();
//3.设置为后台线程
//当前台线程都结束了的时候整个程序也就结束了，即使还有后台线程正在运行
//后台线程不会防止应用程序的进程被终止掉
//如果不设置为后台线程可能导致进程无法正常关闭
t.IsBackground = true;
//4.关闭释放一个线程
//如果开启的线程中不是死循环是能够结束的逻辑那么不用刻意的去关闭它
//如果是死循环想要中止这个线程有两种方式
//4.1-死循环中boo1标识
isrun = false;
//4.2-通过线程提供的方法（注意在.Netcore版本中无法中止会报错
t.Abort();
t = null;
//5.线程休眠
Thread.Sleep();
```
- 线程共享数据
	- 多个线程使用的内存是共享的，都属于该应用程序（进程）
	- 所以要注意当多线程同时操作同一片内存区域时可能会出问题
	- 可以通过加锁的形式避免问题--lock(引用类型对象)
# 预处理器指令
- 指导编译器在实际编译开始之前对信息进行预处理
- 以#开始
```c#
#define
//定义一个符号，类似一个没有值的变量
#undef
//取消define定义的符号，让其失效
//两者都是写在脚本文件最前面
//一般配合if指令使用或配合特性

#if
#elif
#else
#endif
//和if语句规则一样，一般配合#define定义的符号使用
//用于告诉编译器进行编译代码的流程控制

#warning
#error
//告诉编译器
//是报警告还是报错误
//一般还是配合if使用
```
# 反射和特性
## 反射
### 程序集
- 程序集是经由编译器编译得到的，供进一步编译执行的那个中间产物
- 在WINDOWS系统中，它一般表现为后缀为·d11（库文件）或者是·exe（可执行文件）的格式
- 说人话：
	- 程序集就是我们写的一个代码集命，我们现在写的所有代码
	- 最终都会被编译器翻译为一个程序集供别人使用
	- 比如一个代码库文件（d11）或者一个可执行文件（exe）
### 元数据
- 元数据就是用来描述数据的数据
- 这个概念不仅仅用于程序上，在别的领域也有元数据
- 说人话：
	- 程序中的类，类中的函数、变量等等信息就是程序的元数据
	- 有关程序以及类型的数据被称为元数据，它们保存在程序集中
### 反射
- 程序正在运行时，可以查看其它程序集或者自身的元数据。
- 一个运行的程序查看本身或者其它程序的元数据的行为就叫做反射
- 说人话：
	- 在程序运行时，通过反射可以得到其它程序集或者自己程序集代码的各种信息
	- 类，函数，变量，对象等等，实例化它们，执行它们，操作它们
- 可以在程序编译后获得信息，所以它提高了程序的拓展性和灵活性
- 程序运行时得到所有元数据，包括元数据的特性
- 程序运行时，实例化对象，操作对象
- 程序运行时创建新对象，用这些对象执行任务

| 目标值      | 适用于                     |
| -------- | ----------------------- |
| assembly | 整个程序集                   |
| module   | 当前程序集模块                 |
| field    | 类或结构中的字段                |
| event    | 活动                      |
| method   | 方法或 get 和 set 属性访问器     |
| param    | 方法参数或 set属性访问器参数        |
| property | 属性                      |
| return   | 方法、属性索引器或 get 属性访问器的返回值 |
| type     | 结构、类、接口、枚举或委托           |

#### Type
- 它是反射功能的基础
- 它是访问元数据的主要方式
- 使用Type的成员获取有关类型声明的信息
- 有关类型的成员（如构造函数、方法、字段、属性和类的事件）
1. 获取Type
```c#
//object的GetType
Type type = xx.GetType();
//typeof关键字，传入类名
Type type = typeof(xxx);
//通过类名，需包含命名空间
Type type = Type.GetType(xxx);
```
2. 获取公共成员
```c#
MemberInfo[] infos = type.GetMember();
//1.获取所有构造函数
ConstructorInfo[] ctors = type.GetConstructors();
//2.获取一个并执行
//得构造函数传入Type数组数组中内容按顺序是参数类型
//执行构造函数传入object数组表示按顺序传入的参数
//2-1得到无参构造
ConstructorInfo info = type.GetConstructor(new Type[0]);
info.Invoke(null);
//2-2得到有参构造
ConstructorInfo info = type.GetConstructor(new Type[]{typeof(xxx)});
info.Invoke(new object[]{xxx});
```
3. 获取类的公共成员变量
```c#
//1.得到所有成员变量
FieldInfo[] fieldInfos = t.GetFields();
//2.得到指定名称的公共成员变量
FieldInfo Info = t.GetField("变量名");
//3.通过反射获取和设置对象的值
//3-1通过反射获取对象的某个变量的值
Info.GetValue(xxx);
//3-2通过反射设置指定对象的某个变量的值
Info.SetValue(xxx,值);
```
4. 获取类的公共成员方法
```c#
//通过Type类中的GetMethod方法得到类中的方法
//MethodInfo是方法的反射信息
//1.如果存在方法重载用Type数组表示参数类型
MethodsInfo[] methods = type.GetMethods();
MethodsInfo mt = type.GetMethod("方法名",new Type[]{typeof(),typeof()});
//2.调用该方法
//注意：如果是静态方法Invoke中的第一个参数传nul1即可
//第一个参数 那个对象执行这个方法
object result = mt.Invoke(s,new object[]{});

//Others
//Type
//得枚举
//GetEnumName
//事件
//GetEvent
//接口
//GetInterface
//属性
//GetProperty
```
#### Assembly
- 程序集类
- 主要用来加载其它程序集，加载后，才能用Type来使用其它程序集中的信息
- 如果想要使用不是自己程序集中的内容需要先加载程序集
- 比如d11文件（库文件）
- 简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类
```c#
//三种加载程序集的函数
//一般用来加载在同一文件下的其它程序集
//Assembly asembly2= Assembly.Load("程序集名称");

//一般用来加载不在同一文件下的其它程序集
//Assembly asembly=Assembly.LoadFrom("包含程序集清单的文件的名称或路径");
//Assembly asembly3=Assembly.LoadFile("要加载的文件的完全限定路径");
///1.先加载一个指定程序集
Assembly asembly=Assembly.LoadFrom("包含程序集清单的文件的名称或路径");
Type[] types = asembly.GetTypes();

//2.再加载程序集中的一个类对象之后才能使用反射
Type t = asembly.GetType("类");
MemberInfo[] members = t.GetMembers();

//通过反射实例化
//先得到Type得到可传的参数
//直接实例化
//得到方法
//3.类库工程创建
```
#### Activator
- 用于快速实例化对象
- 将Type对象实例化对象
```c#
Type type = typeof(xxx);
//有参构造
Test t = Activator.CreateInstance(type) as xxx;
//无参构造
Test t = Activator.CreateInstance(type,xxx) as xxx;
```
## 特性
- 特性是一种允许我们向程序的程序集添加元数据的语言结构
- 它是用于保存程序结构信息的某种特殊类型的类
- 特性提供功能强大的方法以将声明信息与C#代码（类型、方法、属性等）相关联。
- 特性与程序实体关联后，即可在运行时使用反射查询特性信息
- 特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中
- 它可以放置在几乎所有的声明中（类、变量、函数等等申明）
- 说人话：
	- 特性本质是个类
	- 我们可以利用特性类为元数据添加额外信息
	- 比如一个类、成员变量、成员方法等等为他们添加更多的额外信息，之后可以通过反射来获取这些额外信息
```c#
//定义
继承特性基类 Attribute
class MyAttribute : Attribute{
成员按需求写
}
//使用
[特性名(参数)]
//本质上调用特性类的构造函数
//写在类、函数、变量上一行
MyClass mc = new MyClass();
Type t = mc.GetType();
//判断是否获取某个特性
//参数一：特性的类型
//参数二：是否搜索继承链//属性事件忽略
if(t.IsDefined(typeof(MyAttribute),false)){

}
//获取Type元数据所有特性
object[] array = t.GetCustomAttributes(true);

//通过为特性类加特性限制其使用范围
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)]
//参数一：AttributeTargets一特性能个用在哪些地方
//参数二：AllowMultiple一是否允许多个特性实例用在同一个目标上
//参数三：Inherited一特性是否能被派生类和重写成员继承
```
### 系统自带
- 过时特性
	- Obsolete("",false)//参数一：提示内容；参数二：true使用时报错，false警告
	- 用于提示用户使用的方法等成员已经过时建议使用新方法
	- 一般加在函数前的特性
- 调用者信息特性
	- 哪个文件调用--CallerFilePath特性
	- 哪一行调用--CallerLineNumber特性
	- 哪个函数调用--CallerMemberName特性
	- 需要引l用命名空间usingSystem.Runtime.CompilerServices;
	- 一般作为函数参数的特性
- 条件编译
	- Conditional
	- 它会和预处理指令#define配合使用
	- 需要引用命名空间usingSystem.Diagnostics;
	- 主要可以用在一些调试代码上
	- 有时想执行有时不想执行的代码
- 外部DLL包函数
	- DllImport("文件名/路径")
	- 用来标记非.Net(C#）的函数，表明该函数在一个外部的DLL中定义。
	- 一般用来调用C或者C++的D11包写好的方法
	- 需要引l用命名空间usingSystem.Runtime.InteropServices
# 迭代器
- 迭代器(iterator）有时又称光标(cursor)
- 是程序设计的软件设计模式
- 选代器模式提供一个方法顺序访问一个聚合对象中的各个元素
- 而又不暴露其内部的标识
- 在表现效果上看
	- 是可以在容器对象（例如链表或数组）上遍历访问的接口
	- 设计人员无需关心容器对象的内存分配的实现细节
	- 可以用foreach遍历的类，都是实现了选代器的
- 实现方法
	- 关键接口:IEnumerator,IEnumerable
	- 命名空间:usingSystem.Collections;
	- 可以通过同时继承IEnumerable和IEnumerator实现其中的方法
## foreach本质
- 先获取in后面对象的IEnumerator，调用GetEnumerator方法
- 执行得到IEnumerator对象中的MoveNext方法
- 只要MoveNext返回值是true，得到Current复制给item
- reset重置光标写在获取IEnumerator中
## 用yield return实现迭代器
- 所谓语法糖，也称糖衣语法
- 主要作用就是将复杂逻辑简单化，可以增加程序的可读性
- 从而减少程序代码出错的机会
- 关键接口：IEnumerable
- 命名空间:usingSystem.Collections;
- 让想要通过foreach遍历的自定义类实现接口中的方法GetEnumerator即可
```c#
class CustomList2 :IEnumerable{
	private int[] list;
	public CustomList2(){
		list = new int[] { 1, 2, 3, 4, 5, 6, 7, 8 };	
	}
	public IEnumerator GetEnumerator(){
		for (int i = O; i < list.Length; i++){
			//yield关键字配合迭代器使用
			//可以理解为暂时返回保留当前的状态
			yield return list[i];
		}
	}
}
```
## 用yield return为泛型类实现迭代器
```c#
class CustomList2<T> :IEnumerable{
	private T[] list;
	public CustomList2(params T[] array){
		this.array = array;
	}
	public IEnumerator GetEnumerator(){
		for (int i = O; i < list.Length; i++){
			//yield关键字配合迭代器使用
			//可以理解为暂时返回保留当前的状态
			yield return list[i];
		}
	}
}
```
# 特殊语法
## var隐式类型
- var是一种特殊的变量类型
- 可以用来表示任意类型的变量
- 注意：
	1. var不能作为类的成员只能用于临时变量申明时，也就是一般写在函数语句块中
	2. var必须初始化
## 设置对象初始值--初始化列表
- 声明对象时，可以通过大括号形式初始化公共成员变量和属性
## 设置集合初始值
- 通过大括号初始化内部属性
## 匿名类型
- var变量可声明为自定义的匿名类型
## 可空类型--Nullable
- 值类型不能赋值为空
- < data_type> ? <variable_name> = null;
- 判断为空：HasValue()
- 安全获取值
	- 为空，默认返回值类型的默认值：GetValueOrDefault()
	- 指定默认值：GetValueOrDefault(xxx)，没有给value赋值
- o?.ToString()，为空不会执行ToString，不会报错
- Null 合并运算符（ ?? ）
- 如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值
## 内插字符串
- $，字符串中拼接变量
## 单句逻辑简略写法
# 值类型和引用类型
- class引用
- struct值
## 语句块
1. 命名空间
2. 类、接口、结构体
3. 函数、属性、索引器、运算符重载等（类、接口、结构体）
4. 条件分支、循环
- 上层语句块：类、结构体
- 中层语句块：函数
- 底层的语句块：条件分支循环等
- 逻辑代码写在--函数、条件分支、循环-中底层语句块中
- 变量可以声明在哪里？
	- 上、中、底都能声明变量
	- 上：成员变量
	- 中、底：临时变量
## 生命周期
- 编程时大部分都是临时变量
- 在中底层申明的临时变量（函数、条件分支、循环语句块等）
- 语句块执行结束，没有被记录的对象将被回收或变成垃圾
	- 值类型：被系统自动回收
	- 引用类型：栈上用于存地址的房间被系统自动回收，堆中具体内容变成垃圾，等待GC回收
- 想要不被回收或者不变垃圾，必须将其记录下来
- 如何记录？
- 在更高层级记录，或使用静态全局变量记录
## 结构体中的值和引用
- 本身是值类型
- 前提：该结构体没有做为其它类的成员
- 值：栈中存储值具体的内容
- 引用：堆中存储引用具体的内容，栈中存地址
- 引用类型始终存储在堆中
## 类中的值和引用
- 本身引用类型
- 值，引用：堆中存储
## 数组
- 本身引用
- 值类型数组，堆中存值
- 引用，存地址
## 结构体继承接口
- 里氏替换，接口容器装载结构体存在装箱拆箱