# Session实现登录
![[Pasted image 20260118172735.png]]
1. 发送验证码
	- 请求方式POST
	- 路径/user/code
	- 参数phone
	- 返回值无
```java
@Override  
public Result sedCode(String phone, HttpSession session) {  
    //1. 校验手机号  
    if (RegexUtils.isPhoneInvalid(phone)) {  
        //2.如果不符合，返回错误信息  
        return Result.fail("手机号格式错误");  
    }  
  
    //3. 符合，生成验证码  
    String code = RandomUtil.randomNumbers(6);  
    //4. 保存验证码到session  
    session.setAttribute("code",code);  
    //5. 发送验证码  
    log.debug("发送短信验证码成功，验证码:{}",code);  
    //返回ok  
    return Result.ok();  
}
```
2. 登录
	- 请求方式POST
	- 路径/user/login
	- 参数phone，code
	- 返回值无
```java
@Override  
public Result login(LoginFormDTO loginForm, HttpSession session) {  
    //1. 校验手机号  
    String phone = loginForm.getPhone();  
    if (RegexUtils.isPhoneInvalid(phone)) {  
        return Result.fail("手机号格式错误");  
    }  
    //2. 校验验证码  
    Object cacheCode = session.getAttribute("code");  
    String code = loginForm.getCode();  
    if (cacheCode == null || !cacheCode.toString().equals(code)){  
        //3. 不一致，报错  
        return Result.fail("验证码错误");  
    }  
  
    //4.一致，根据手机号查询用户  
    User user = query().eq("phone", phone).one();  
  
    //5. 判断用户是否存在  
    if (user == null){  
        //6. 不存在，创建新用户  
        user = createUserWithPhone(phone);  
    }  
  
    //7.保存用户信息到session  
    session.setAttribute("user",BeanUtil.copyProperties(user,UserDTO.class));  
    return Result.ok();  
}
private User createUserWithPhone(String phone) {  
    // 1.创建用户  
    User user = new User();  
    user.setPhone(phone);  
    user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(10));  
    // 2.保存用户  
    save(user);  
    return user;  
}
```
3. 登录校验
- 使用拦截器过滤请求，用户数据保存到ThreadLocal
![[Pasted image 20260118181655.png]]
```java
public class LoginInterceptor implements HandlerInterceptor {  
    @Override  
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  
        //1. 获取session  
        HttpSession session = request.getSession();  
        //2.获取session中的用户  
        Object user = session.getAttribute("user");  
        //3. 判断用户是否存在  
        if (user == null){  
            //4. 不存在，拦截，返回401  
            response.setStatus(401);  
            return false;  
        }  
  
        //5. 存在 保存用户信息到ThreadLocal  
        UserHolder.saveUser((UserDTO) user); 
        //隐藏用户信息，直接返回user对象能直接看到
        //6. 放行  
        return true;  
    }  
  
    @Override  
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {  
        //移除用户  
        UserHolder.removeUser();  
    }  
}

//配置拦截器
@Configuration  
public class MvcConfig implements WebMvcConfigurer {  
  
    @Resource  
    private StringRedisTemplate stringRedisTemplate;  
  
    @Override  
    public void addInterceptors(InterceptorRegistry registry) {  
        // 登录拦截器  
        registry.addInterceptor(new LoginInterceptor())  
                .excludePathPatterns(  
                        "/shop/**",  
                        "/voucher/**",  
                        "/shop-type/**",  
                        "/upload/**",  
                        "/blog/hot",  
                        "/user/code",  
                        "/user/login"  
                );  
    }  
}
```
## session共享问题
- 多台tomcat不共享session存储空间，请求切换到不同tomcat服务导致数据丢失
- 替代需满足：数据共享、内存存储、kv结构
## 基于Redis实现session共享登录
- 数据类型选择，key选择
![[Pasted image 20260119164352.png]]
1. 发送验证码
```java
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {  
  
    @Resource  
    private StringRedisTemplate stringRedisTemplate;  
    @Override  
    public Result sedCode(String phone, HttpSession session) {  
        //1. 校验手机号  
        if (RegexUtils.isPhoneInvalid(phone)) {  
            //2.如果不符合，返回错误信息  
            return Result.fail("手机号格式错误");  
        }  
  
        //3. 符合，生成验证码  
        String code = RandomUtil.randomNumbers(6);  
        //4. 保存验证码到redis，加前缀区分  
        stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY+phone,code,LOGIN_CODE_TTL, TimeUnit.MINUTES);  //修改保存逻辑，使用redis模板保存，使用工具定义的常量
        //5. 发送验证码  
        log.debug("发送短信验证码成功，验证码:{}",code);  
        //返回ok  
        return Result.ok();  
    }
```
![[Pasted image 20260119163941.png]]
2. 短信验证登录
```java
@Override  
public Result login(LoginFormDTO loginForm, HttpSession session) {  
    //1. 校验手机号  
    String phone = loginForm.getPhone();  
    if (RegexUtils.isPhoneInvalid(phone)) {  
        return Result.fail("手机号格式错误");  
    }  
    //TODO 2. 从redis获取并校验验证码  
    String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY+phone);  
    String code = loginForm.getCode();  
    if (cacheCode == null || !cacheCode.equals(code)){  
        //3. 不一致，报错  
        return Result.fail("验证码错误");  
    }  
  
    //4.一致，根据手机号查询用户  
    User user = query().eq("phone", phone).one();  
  
    //5. 判断用户是否存在  
    if (user == null){  
        //6. 不存在，创建新用户  
        user = createUserWithPhone(phone);  
    }  
  
    //TODO 7.保存用户信息到redis  
    //7.1 随机生成token作为登录令牌  
    String token = UUID.randomUUID().toString(true);  
    // 7.2 将user对象转为hash存储  
    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);  
    Map<String, Object> userMap = BeanUtil.beanToMap(userDTO);  
    // 7.3 存储  
    stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY+token,userMap);  
    //7.4 设置有效期  
    stringRedisTemplate.expire(LOGIN_USER_KEY+token,LOGIN_USER_TTL, TimeUnit.MINUTES);  
    //8 返回token  
    return Result.ok(token);  
}
```
# 缓存
- 数据交换的缓冲区，存储数据的临时地方，读写性能高
- 降低后端负载，提高读写效率，降低响应时间
- 数据一致性问题，维护、运维成本
## 缓存更新策略

|          |                           内存淘汰                            |                          超时剔除                           |                 主动更新                 |
| -------- |:-------------------------------------------------------------:|:-----------------------------------------------------------:|:----------------------------------------:|
| 说明     | redis内存淘汰机制<br>内存不足自动淘汰数据<br>下次查询更新缓存 | 给缓存添加TTL时间<br>到期自动删除缓存<br>下次查询时更新缓存 | 编写业务逻辑<br>修改数据库时<br>更新缓存 |
| 一致性   |                              差                               |                            一般                             |                    好                    |
| 维护成本 |                              无                               |                             低                              |                    高                    |
- 低一致性：内存淘汰
- 高一致性：主动更新，以超时剔除作为兜底
### 主动更新实现
1. Cache Aside Pattern--旁路缓存模式
	- 由缓存的调用者，在更新数据库的同时更新缓存
	1. 删除缓存：更新数据时使缓存失效，查询时在更新缓存
		- 更新缓存：每次更新数据都更新缓存，无效操作多
	2. 保证缓存与数据库操作的同时成功/失败
		- 单体系统，将缓存与数据库操作放在一个事务
		- 分布式系统，利用TCC等分布式事务方案
	3. 先写数据库，再删缓存
2. Read/Write Through Pattern--读/写直通模式
	- 缓存与数据库整合为一个服务，由服务维护一致性。调用者调用该服务，无需关心缓存一致性问题
3. Write Behind Caching Pattern--编写后置缓存模式
	- 调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保证一致性
## 缓存穿透
- 客户端请求的数据再缓存中和数据库中都不存在，缓存不生效，请求直接打数据库
### 缓存空对象
- 缓存null
- 实现简单
- 额外内存消耗，短期不一致
### 布隆过滤
- 客户端和redis中加一层
- 存在放行，不存在拒绝
- 内存占用少，没有多余key
- 实现复杂，存在误判可能
## 缓存雪崩
- 同一时间段内大量的缓存key同时失效或redis服务宕机，导致大量数据请求到达数据库
- 解决方案
	- 给不同key的ttl添加随机值
	- 利用redis集群提高服务的可用性
	- 给缓存业务提娜佳降级限流策略
	- 给业务添加多级缓存
		- 浏览器
		- nginx
		- redis
		- dvm
## 缓存击穿
- 热点key问题，一个被高并发访问并且缓存重建业务复杂的key失效

| 方案   | 优                         | 缺                          |
| ---- | ------------------------- | -------------------------- |
| 互斥锁  | 没有额外内存消耗<br>保证一致性<br>实现简单 | 线程需等待，性能受影响<br>有死锁风险       |
| 逻辑过期 | 线程无需等待<br>性能好             | 不能保证一致性<br>有额外内存消耗<br>实现复杂 |
## 封装成工具类
# 秒杀
### 全局唯一ID
- 分布式系统下用来生成全局唯一ID
	- 唯一性、递增性、安全性
	- 高可用、高性能
- 使用long
	- 符号位：1bit，永远为0
	- 时间戳：31bit，以秒为单位可以使用69年
	- 序列号：32bit，秒内计数器
- UUID
- Redis自增
- snowflake
- 数据库自增
## 超卖

| 悲观锁                                   | 乐观锁                                        |
| ------------------------------------- | ------------------------------------------ |
| 认为线程安全问题一定会发生<br>在数据操作前先获取锁<br>确保线程执行 | 线程安全问题不一定会发生，不加锁<br>只在更新数据时去判断有没有其他线程对数据修改 |
| Synchronized、Lock                     | - 没有修改认为是安全的，自己更新数据<br>- 被修改，重试或异常         |
| 简单粗暴<br>性能一般                          | 性能好<br>成功率低                                |
### 乐观锁
- 版本号法
	- 查询时查询数据和版本号，每次修改版本号加1，修改时判断版本号是否相同
- CAS
	- 使用库存代替版本号
## 一人一单
- 一个用户只能下一单
- 加悲观锁
## 分布式锁
- 满足分布式系统或集群模式下多进程可见并且互斥的锁

|     |   MySQL    |   Redis    |   Zookeeper   |
| --- | :--------: | :--------: | :-----------: |
| 互斥  |   本身的互斥锁   |  setnx命令   |   节点唯一性和有序性   |
| 高可用 |     好      |     好      |       好       |
| 高性能 |     一般     |     好      |      一般       |
| 安全性 | 断开链接，自动释放锁 | 锁超时时间，到期释放 | 临时节点，断开链接自动释放 |
### 基于redis
- 获取锁
	- 互斥：确保只能有一个线程获取锁
	- 非阻塞：尝试一次，成功返回true，失败返回false
	- `改进`：存线程表示（UUID
- 释放锁
	- 手动释放--`误删问题，自己的锁过期业务未完成`
	- 超时自动释放
	- `改进`：先获取线程表示，判断是否与当前线程标识相同
		- 一致释放
		- 不一致不释放
		- 问题：`JVM回收阻塞删除`
			- Lua脚本：一次执行多个Redis语句，保证原子性
				- 脚本中的key、value不想写死，可以作为参数传递
				- key类型参数会放入KEYS数组
	1. 获取锁中的线程标识
	2. 判断释放与指定的标识（当前线程标识）一致
	3. 一致释放锁（删除）
	4. 不一致什么都不做
#### 优化
- 基于setnx问题
	- 不可重复：一个线程无法多次获取同一把锁
	- 不可重试：尝试一次返回false
	- 超时释放：避免死锁，如果执行耗时较长，也会导致锁释放，存在安全隐患
	- 主从一致：主从同步存在延迟，主宕机，如果从并同步主中的锁数据，会出现锁实现
### Redisson
- 在redis基础上实现的java驻内存数据网格
- 分布式工具集合
#### 可重入锁原理
- 类似ReentrantLock
- 有锁判断锁是否是自己的，获取次数加一
- 释放判断是否是自己的，是次数减一，计数是否为0，重置有效期
- 获取锁
```lua
local key = KEYS[1]; -- 锁的key
local threadId = ARGV[1]；-- 线程唯一标识
local releaseTime = ARGV[2]； -- 锁的自动释放时间
--判断是否存在
if(redis.call('exists', key) == 0) then
	--不存在，获取锁
	redis.call('hset', key, threadId, '1');
	--设置有效期
	redis.call('expire', key, releaseTime);return 1；
	-- 返回结果
end;
--锁已经存在，判断threadId是否是自己
if(redis.call('hexists', key, threadId) == 1) then
	--不存在，获取锁，重入次数+1
	redis.call('hincrby', key, threadId, '1');
	--设置有效期
	redis.call('expire', key, releaseTime);
	return 1；-- 返回结果
end;
return 0;--代码走到这里，说明获取锁的不是自己，获取锁失败
```
- 释放锁
```lua
local key = KEYS[1]; -- 锁的key
local threadId = ARGV[1]；-- 线程唯一标识
local releaseTime = ARGV[2]； -- 锁的自动释放时间
--判断当前锁是否还是被自己持有
if (redis.call('HExIsTs', key, threadId) == O) then
	return nil；-- 如果已经不是自己，则直接返回
end;
--是自己的锁，则重入次数一1
local count = redis.call('HINcRBY', key, threadId, -1);
--判断是否重入次数是否已经为0
if （count > 0） then
	--大于0说明不能释放锁，重置有效期然后返回
	redis.call('ExPIRE', key, releaseTime);
	return nil;
else --等于0说明可以释放锁，直接删除
	redis.call('DEL', key);
	return nil;
end ;
```
## 秒杀优化
- 将判断校验功能独立出去，放入redis
1. 新增秒杀优惠券的同时，将优惠券信息保存到Redis中
2. 基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功
3. 如果抢购成功，将优惠券id和用户id封装后存入阻塞队列
4. 开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能
- 利用redis完成库存余量、一人一单，完成抢单
- 下单放入阻塞队列，利用独立线程异步下单
## 消息队列
- 存放消息的队列
	- 消息队列：存储和管理消息，消息代理
	- 生产者：发送给消息到消息队列
	- 消费者：从消息队列获取消息并处理消息
- Redis提供了三种不同的方式实现消息队列
### `list结构`：基于list结构模拟消息队列
- 优
	- Redis存储，不受限JVM内存上限
	- 基于Redis持久化，数据安全有保障
	- 有序性
- 缺
	- 无法避免消息丢失
	- 只支持单消费者
### `PubSub`(发布订阅：基本的点对点消息模型，2.0
- 消息传递模型。消费者订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息
	- `SUBSCRIBE channel [channel] `：订阅一个或多个频道
	- `PUBLISH channel msg` ： 向一个频道发送消息
	- `PSUBSCRIBE pattern[pattern]`：订阅与pattern格式匹配的所有频道
- 优
	- 发布订阅模型，支持多生产、多消费
- 缺
	- 不能持久化
	- 无法避免消息丢失
	- 堆积有上限，超出丢失
### `Stream`：比较完善的消息队列模型，5.0
- xadd
- xread
- 优
	- 消息可回溯
	- 一个消息可以被多个消费者读取
	- 可以阻塞读取
- 缺
	- 有消息漏读的风险
#### `消费者组`：将多个消费者划分到一个组中，监听同一个队列
- 消息分流：消息分流给组内不同消费者，不重复消费，加快处理速度
- 消息标识：维护一个标识，记录最后一个被处理的消息，确保每个消息被消费
- 消息确认：消费者获取消息后，消息处于pending状态，并存入一个pending-list。当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pending-list移除
- XGROP
- XREADGROUP
- XACK 
- 消息可回溯
- 可以多消费者争抢消息，加快消费速度
- 可以阻塞读取
- 没有消息漏读的风险
- 有消息确认机制，保证消息至少被消费一次

|        |          List           |  PubSub   |            Stream             |
| ------ | :---------------------: | :-------: | :---------------------------: |
| 消息持久化  |           支持            |    不支持    |              支持               |
| 阻塞读取   |           支持            |    支持     |              支持               |
| 消息堆积处理 | 受限于内存空间<br>可以利用多消费者加快处理 | 受限于消费者缓冲区 | 受限于队列长度<br>可以利用消费者组提高消费速度减少堆积 |
| 消息确认机制 |           不支持           |    不支持    |              支持               |
| 消息回湖   |           不支持           |    不支持    |              支持               |
# 达人探店
## 点赞榜

|          |           List           |     Set      |    Sortedset    |
| -------- |:------------------------:|:------------:|:---------------:|
| 排序方式 |      按添加顺序排序      |   无法排序   | 根据score值排序 |
| 唯一性   |          不唯一          |     唯一     |      唯一       |
| 查找方式 | 按索引查找<br>或首尾查找 | 根据元素查找 |  根据元素查找   |
## 关注推送
- feed流，为用户持续的提供沉浸式体验，无限下拉刷新获取新的消息
### Timeline
- 不做内容筛选，简单单招内容发布时间排序，常用于好用或关注
- 优：信息全面，没有缺失。实现简单
- 缺：信息噪点多，用户不一定感兴趣，内容获取效率低
#### 三种模式
1. 拉模式：读扩散
	- 消息发到发件箱，读取时拉到收件箱
2. 推模式：写扩散
	- 直接发到收件箱
3. 推拉结合：读写混合

|              |  拉模式  |      推模式       |       推拉结合        |
| ------------ |:--------:|:-----------------:|:---------------------:|
| 写比例       |    低    |        高         |          中           |
| 读比例       |    高    |        低         |          中           |
| 用户读取延迟 |    高    |        低         |          低           |
| 实现难度     |   复杂   |       简单        |        很复杂         |
| 使用场景     | 很少使用 | 用户量少、没有大V | 过千万的用户量，有大V |
- 分页问题
- 数据更新导致角标变化，不能使用传统分页
### 智能排序
- 利用智能算法屏蔽掉违规、用户不感兴趣的内容，推送用户感兴趣信息吸引用户
- 优：投喂感兴趣信息，用户粘性高，易沉迷
- 缺：算法不精确会起到反作用
# 附近商户
GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：
- `GEOADD`：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）
- `GEODIST`：计算指定的两个点之间的距离并返回
- `GEOHASH`：将指定member的坐标转为hash字符串形式并返回
	- 哈希降维：先将经纬度坐标值 转换成 二进制的数字，然后再利用特殊的编码 转换成 对应的字符串，转换成字符串后，占用的空间就会小一点，节省内存
- `GEOPOS`：返回指定member的坐标
- ~~`GEORADIUS`：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.2以后已废弃~~
- `GEOSEARCH`：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能
- `GEOSEARCHSTORE`：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能
# 用户签到
- BitMap：每一个bit对应当月的每一天，形成了映射关系。用0和1标示业务状态，位图
- Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是2^32个bit位
- BitMap的操作命令有：
	- `SETBIT`：向指定位置（offset）存入一个O或1
	- `GETBIT`：获取指定位置（offset）的bit值
	- `BITCOUNT`：统计BitMap中值为1的bit位的数量
	- `BITFIELD`：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值
	- `BITFIELD_RO`：获取BitMap中bit数组，并以十进制形式返回
	- `BITOP`：将多个BitMap的结果做位运算（与、或、异或）
	- `BITPOS`：查找bit数组中指定范围内第一个0或1出现的位置
- 连续签到统计
# UV统计
- UV：全称UniqueVisitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。
- PV：全称PageVieW，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。
- Hyperloglog（HLL）是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：https://juejin.cn/p0st/6844903785744056333#heading-0
- Redis中的HLL是基于string结构实现的，单个HLL的内存永远小于16kb，内存占用低的令人发指！作为代价，其测量结果是概率性的，有小于0.81%的误差。不过对于UV统计来说，这完全可以忽略。