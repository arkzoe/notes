# 集合框架
- 容器
	- Collection:单列集合，每个元素只包含一个值
	- Map:双列集合，每个元素包含两个值--键值对
![[集合框架.png]]
# Collection
![[单列.png]]
## Collection 常用功能

| 方法名                                 |                  |
| ----------------------------------- | ---------------- |
| public boolean add(E e)             | 把给定的对象添加到当前集合中   |
| public void clear()                 | 清空集合中所有的元素       |
| public boolean remove(E e)          | 把给定的对象在当前集合中删除   |
| public boolean contains(object obj) | 判断当前集合中是否包含给定的对象 |
| public boolean isEmpty()            | 判断当前集合是否为空       |
| public int size()                   | 返回集合中元素的个数       |
| public Object[] toArray()           | 把集合中的元素，存储到数组中   |

## 遍历方式
### 迭代器遍历
- 迭代器是专门用于遍历集合的方法，代表Iterator
#### 遍历一：迭代器

| 方法名称                    |                                   |
| ----------------------- | --------------------------------- |
| Iterator< E> iterator() | 返回集合中的送代器对象，该送代器对象默认指向当前集合的第一个元素  |
| boolean hasNext()       | 询问当前位置是否有元素存在，存在返回true，不存在返回false |
| E next()                | 获取当前位置的元素，并同时将迭代器对象指向下一个元素处      |

```java
while(it.hasNext()){
	String name = it.next();
	...
}
```
#### 遍历二：for
```java
for (元素类型 变量名：数组/集合){

}
```
#### 遍历三：Lambda

| 方法名称                                              |              |
| ------------------------------------------------- | ------------ |
| default void forEach(Consumer< ? super T> action) | 结合lambda遍历集合 |

底层for实现
### 区别
- 并发修改异常--遍历时又增删
1. 迭代器遍历--用迭代器方法删除
2. for/Lambda--无法解决
- 支持索引 for
- 否迭代器
## List系列
- 添加元素是有序、可重复、有索引
- 特有功能

| 方法名称                          |                      |
| ----------------------------- | -------------------- |
| void add(int index,E element) | 在此集合中的指定位置插入指定的元素    |
| E remove(int index)           | 删除指定索引处的元素，返回被删除的元素  |
| E set(int index,E element)    | 修改指定索引1处的元素，返回被修改的元素 |
| E get(int index)              | 返回指定索引处的元素           |

#### 支持遍历
1. for
2. 迭代器
3. 增强for
4. Lambda
### ArrayList 原理
- 数组
- 查询快：索引查询
- 增删慢
### LinkedList 原理
- 双链表
- 查询慢
- 增删快

| LinkedList特有方法            |                  |
| ------------------------- | ---------------- |
| public void addFirst(E e) | 在该列表开头插入指定的元素    |
| public void addLast(E e)  | 将指定的元素追加到此列表的末尾  |
| public E getFirst()       | 返回此列表中的第一个元素     |
| public E getLast()        | 返回此列表中的最后一个元素    |
| public E removeFirst()    | 从此列表中删除并返回第一个元素  |
| public E removeLast()     | 从此列表中删除并返回最后一个元素 |

#### 应用
- 设计队列
- 设计栈
#### [[Set]]系列
- 添加元素是无序、不重复、无索引
	- LinkedHashSet:==有序==
	- TreeSet:==按大小默认升序排序==
- 常用功能Collection
## 原理
### HashSet
#### 哈希值
- java中每个对象都有一个哈希值
- 调用Object的hashCode方法，返回哈希值
- public int hashCode()
#### 哈希表
- JDK8之前，数组+链表
	1. 创建默认长度16的数组，默认加载因子0.75，数组名table
	2. 用==哈希值==对==数组长度做运算==计算出位置
	3. 判断位置是否为null，null存入
	4. ==不是null，用equals比较，相等不存；不相等，存
		- 链地址法 
		- JDK8 前，新元素占老元素位置，老元素挂下面
		- JDK8 后，新元素挂老元素下面
- JDK8开始，数组+链表+红黑树--==链表长度超过8，数组长度>=64，将链表转成红黑树==
	- 二叉排序树
		- 小左，大右
	- 平衡二叉树
		- 满足查找二叉树规则下，让树尽可能矮
	- 红黑树-自平衡的二叉树
		- 增删改查性能好
#### 去重操作
- 重写 hashCode()和equals()
### LinkedHashSet原理
- 基于哈希表（数组+链表+红黑树）实现
- 每个元素多了双链表记录前后元素的位置
### TreeSet原理
- 红黑树
- 对象类实现 Comparable 比较接口，重写 compareTo 方法，指定比较规则
	- 左大正，右大负，等为0--默认升序
- public TreeSet (Compartor c) 自带 Comparable 对象，指定比较规则
	- Double.compare()
# Map
![[Map.png]]
- 健不能重复
- 存一一对应的数据
#### 特点
- 由键决定特点
- `添加元素`是`无序`、不重复、无索引
	- LinkedHashMap:==有序==
	- TreeMap:==按大小默认升序排序==
### 常用方法

| 方法名称                                       |                       |
| ------------------------------------------ | --------------------- |
| public V put(K key,V value)                | 添加元素                  |
| public int size()                          | 获取集合的大小               |
| public void clear()                        | 清空集合                  |
| public boolean isEmpty()                   | 判断集合是否为空，为空返回true ，反之 |
| public V get(object key)                   | 根据键获取对应值              |
| public V remove(object key)                | 根据键删除整个元素             |
| public boolean containsKey(Object key)     | 判断是否包含某个键             |
| public boolean containsValue(object value) | 判断是否包含某个键             |
| public Set< K> keySet()                    | 获取全部键的集合              |
| public Collection<V> values()              | 获取Map集合的全部值           |

### 遍历方法
#### 健找值
- 先获取Map集合全部的键，再遍历键
```java
public Set <K> keySet()
public V get(Object key)
```
#### 键值对
- 看成一个整体
```java
Set<Map.Entry<K,V>> entrySet() //获取所有键值对集合
Set<Map.Entry<K,V>> entries = map.entrySet();
for(Map.Entry<K,V> entry : entries){
	key = entry.getKey()
	value = entry.getValue()
}
```
- Map换成Set集合，Entry对象
#### Lambda表达式

| 方法名                                                            |                 |
| -------------------------------------------------------------- | --------------- |
| default void forEach(BiConsumer< ? super K, ? super V> action) | 结合lambda遍历Map集合 |

```java
map.forEach(new BiConsumer<K,V>(){
	public void accpet(K k,V v){
		System.out.println();
	}
});
map.forEach((k,v) -> System.out.println());
```
增强for实现
### 实现类
- HashMap（由键决定特点）：无序、不重复、无索引l；
- LinkedHashMap（由键决定特点）：由键决定的特点：有序、不重复、无索引
- TreeMap（由键决定特点）：按照大小默认升序排序、不重复、无索引
- Set基于Map实现--Set原理就是Map原理