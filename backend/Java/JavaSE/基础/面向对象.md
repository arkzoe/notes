# javabean
- 一种规范，必须满足四个原则

1. **类必须是公共的（public）**：用 `public class 类名` 定义；
2. **提供无参构造方法**：要么显式写 `public 类名(){}`，要么不写（Java 会默认生成）；
3. **私有成员变量（字段）**：所有数据字段用 `private` 修饰（封装性）；
4. **提供公共的 getter/setter 方法**：
    - 读字段：`getXxx()`（布尔类型可以用 `isXxx()`，比如 `isMale()`）；
    - 写字段：`setXxx()`；
    - 命名规则：字段名首字母小写，方法名是 `get/set + 首字母大写的字段名`（比如字段 `username` → `getUsername()`/`setUsername()`）

# Static
- 一个修饰符，可以修饰**变量、方法、代码块、内部类**
- 被 `static` 修饰的成员，属于**类本身**，而不是类的某个具体对象（实例）

## 用法
1. **静态变量（类变量）**
	- 定义：用 `static` 修饰的成员变量，属于类，存储在方法区，全局唯一
	- 访问方式：`类名.静态变量名`
	- 修改静态变量后，所有对象的该变量值都会同步变化，因为它是类级别的共享数据
2. **静态方法（类方法）**
	- 定义：用 `static` 修饰的方法，属于类，不依赖对象即可调用
	- 核心限制：静态方法中**不能直接访问非静态成员**（非静态变量 / 非静态方法），因为静态方法加载时，对象还没创建；但非静态方法可以访问静态成员
	- 访问方式：`类名.静态方法名()`
	- 常见应用：工具类（如 `java.lang.Math`、`java.util.Arrays`）的方法都是静态方法，方便直接调用
3. **静态代码块**
	- 定义：用 `static {}` 包裹的代码块，属于类，**类加载时执行且仅执行一次**（优先于构造方法）
	- 作用：初始化静态变量、执行类级别的初始化逻辑（比如加载配置文件、初始化连接池）
4. **静态内部类**
- **定义**：用 `static` 修饰的内部类，属于外部类本身，而非外部类的对象
- **特点**：可以直接创建静态内部类对象，无需先创建外部类对象；静态内部类中只能访问外部类的静态成员

# 多态
### 一、多态的核心定义（对象多态 + 行为多态）

多态是 Java 面向对象的三大特性之一（封装、继承、多态），核心分为两层：

- **对象多态**：父类引用可以指向子类对象（如 `Animal animal = new Cat();`），这是多态的表现形式；
- **行为多态**：同一方法调用，根据指向的子类对象不同，执行不同的实现（即方法重写后的逻辑），这是多态的核心本质

### 二、多态的核心执行规则（关键口诀）

| 成员类型 | 执行规则                               |
| -------- | -------------------------------------- |
| 成员方法 | 编译看左边（父类），运行看右边（子类） |
| 成员变量 | 编译、运行都看左边（父类）             |

- **方法**：编译时检查父类是否有该方法（没有则编译报错），运行时执行子类重写后的方法；
- **变量**：无论编译还是运行，都使用父类中定义的变量值（子类同名变量不会被访问），因此**成员变量不谈多态**

### 三、多态中的类型转换（解决子类独有功能调用问题）
多态的类型转换分为两种，核心是 “基于对象的真实类型转换”：

|转换类型|语法格式|适用场景|注意事项|
|---|---|---|---|
|自动类型转换（向上转型）|`父类类型 变量名 = new 子类类型();`|多态的默认写法，日常使用父类通用功能|安全，无需手动处理，JVM 自动完成|
|强制类型转换（向下转型）|`子类类型 变量名 = (子类类型) 父类变量;`|需要调用子类独有功能时|1. 编译阶段：只要有继承 / 实现关系就不报错；<br><br>2. 运行阶段：若父类变量指向的真实对象类型 ≠ 强转的子类类型，抛出 `ClassCastException`（类型转换异常）；<br><br>3. 强制转换前，必须用 `instanceof` 判断真实类型，避免异常|

#### `instanceof` 关键字（类型判断）
- 语法：`对象变量 instanceof 类型` → 返回 `boolean`（true = 对象是该类型 / 其子类型，false = 不是）；
- 作用：强制类型转换前，判断对象真实类型，避免 `ClassCastException`

# 继承
### 一、继承的核心定义

继承是 Java 面向对象三大特性（封装、继承、多态）之一，核心是：

> 让一个类（子类 / 派生类）复用另一个类（父类 / 超类 / 基类）的属性和方法，同时可以扩展自己的独有功能

打个比方：

- 父类：`Phone`（手机），有基础功能（打电话、发短信）；
- 子类：`SmartPhone`（智能手机），继承 `Phone` 的所有基础功能，还新增了自己的独有功能（上网、拍照）

继承的本质是**代码复用 + 功能拓展**，避免重复编写相同的代码

### 二、继承的核心语法
#### 1. 基本语法

java

运行

```
// 父类（基类）
public class 父类名 {
    // 成员变量、方法
}

// 子类（派生类）：使用 extends 关键字继承父类
public class 子类名 extends 父类名 {
    // 可以新增子类独有变量/方法
    // 可以重写父类方法（为多态做准备）
}
```

#### 2. 核心规则（必须牢记）

|规则|说明|
|---|---|
|单继承限制|Java 只支持**单继承**（一个子类只能直接继承一个父类），避免多继承带来的逻辑混乱；但支持**多层继承**（A→B→C，C 继承 B，B 继承 A）|
|访问权限|子类只能继承父类的 `public`、`protected`、默认（包访问权限）成员；`private` 成员无法直接继承（但可通过父类的 getter/setter 间接访问）|
|构造方法|子类不能继承父类的构造方法，但子类构造方法**必须先调用父类构造方法**（默认调用父类无参构造，或通过 `super()` 手动调用）|
|方法重写|子类可以重写父类的非 `final`、非 `static` 方法（遵循 “两同两小一大” 规则），这是多态的前提|

### 三、继承的核心特性（重点）
#### 1. 代码复用（最核心价值）
子类无需重新编写父类已有的属性和方法，直接继承使用

#### 2. 方法重写（@Override）
子类可以修改父类方法的实现逻辑，满足自身需求，是多态的基础

- 重写规则（两同两小一大）
	- 两同：方法名、参数列表完全相同；
	- 两小：子类方法的返回值类型 ≤ 父类（子类是父类的子类）、子类方法抛出的异常 ≤ 父类；
	- 一大：子类方法的访问权限 ≥ 父类（如父类是 `protected`，子类可改为 `public`）

#### 3. super 关键字（访问父类成员）
子类中用 `super` 可以：

- 访问父类的成员变量：`super.变量名`；
- 调用父类的成员方法：`super.方法名()`；
- 调用父类的构造方法：`super()`（必须放在子类构造方法第一行）

#### 4. final 关键字（限制继承）

- `final` 修饰类：该类不能被继承（如 `java.lang.String`）；
- `final` 修饰方法：该方法不能被子类重写；
- `final` 修饰变量：变量值不能被修改（常量）
# final
### 一、final 的核心定义

`final` 中文译作 “最终的、不可变的”，是 Java 中的一个修饰符，可以修饰**类、方法、变量**（成员变量、局部变量、参数）
核心本质：被 `final` 修饰的元素，一旦确定就**不能被修改 / 改变**，是一种 “不可变” 的约束

### 二、final 修饰不同元素的规则（核心）

#### 1. final 修饰类：“不可继承的类”
- **规则**：被 `final` 修饰的类，不能被任何子类继承（即没有子类）
- **目的**：保护类的设计不被修改，确保类的功能和逻辑稳定
- **典型案例**：Java 核心类库中的 `java.lang.String`、`java.lang.Integer` 等包装类都是 `final` 类，避免被继承篡改核心逻辑
#### 2. final 修饰方法：“不可重写的方法”
- **规则**：被 `final` 修饰的方法，子类**不能重写**该方法（但可以继承使用）
- **目的**：保护父类的核心方法逻辑不被子类篡改，确保方法行为稳定
- **注意**：`static` 方法本身不能被重写（静态方法属于类，不是对象），所以 `final` 修饰 `static` 方法无意义（但语法上允许）
#### 3. final 修饰变量：“不可修改的常量”
- `final` 修饰变量是最常用的场景，核心规则是 “**只能赋值一次，赋值后不可修改**”，根据变量类型（成员变量 / 局部变量）有细微差异：

##### （1）修饰局部变量 / 方法参数
- **规则**：
    
    1. 声明时可以先不赋值（空白 final），但**使用前必须赋值且仅赋值一次**；
    2. 赋值后不能修改值（基本类型），或不能修改引用（引用类型）
- **关键区别**：
    - 基本类型（int、double 等）：`final` 约束**值不可变**；
    - 引用类型（对象、数组）：`final` 约束**引用地址不可变**，但对象的成员变量可以修改

##### （2）修饰成员变量（类变量 / 实例变量）
- **规则**：
    1. 实例变量（无 static）：必须在**声明时、构造方法、初始化块**中赋值（三者选其一），且仅赋值一次；
    2. 类变量（有 static）：必须在**声明时、静态代码块**中赋值（二者选其一），且仅赋值一次；
    3. 赋值后不可修改
- **常用写法**：`public static final` 组合定义**全局常量**（如 `Math.PI`），命名规范：全大写，单词间用下划线分隔

# 代码块
### 一、代码块的核心定义
代码块是用 `{}` 包裹的一段代码，在 Java 中属于类的成员（和变量、方法、构造方法同级），核心作用是**初始化数据**（类的静态数据、对象的实例数据）

根据是否带 `static` 修饰，代码块分为两类：
- **静态代码块**（static 代码块）：属于类，类加载时执行；
- **实例代码块**（非静态代码块）：属于对象，创建对象时执行

### 二、代码块的分类与核心规则

#### 1. 静态代码块（类级初始化）

|特征|说明|
|---|---|
|语法|`static { 代码逻辑 }`|
|归属|属于**类本身**，而非对象|
|执行时机|类加载时执行（JVM 第一次加载该类时），**仅执行一次**|
|执行顺序|多个静态代码块按 “定义顺序” 执行；优先于实例代码块、构造方法|
|访问权限|只能访问类的**静态成员**（静态变量、静态方法），不能访问实例成员|
|核心作用|初始化静态变量、加载全局配置、初始化类级资源（如数据库连接池）|

#### 2. 实例代码块（对象级初始化）

|特征|说明|
|---|---|
|语法|`{ 代码逻辑 }`（无 static 修饰）|
|归属|属于**对象**，每个对象创建时都会执行|
|执行时机|创建对象时（调用构造方法前）执行，**每个对象创建时都执行一次**|
|执行顺序|多个实例代码块按 “定义顺序” 执行；在静态代码块之后、构造方法之前|
|访问权限|可以访问类的**所有成员**（静态成员、实例成员）|
|核心作用|提取多个构造方法的公共初始化逻辑，避免重复代码|

### 三、代码块的执行顺序
核心规则：
> 静态代码块（类加载时仅执行一次） → 实例代码块（对象创建时执行） → 构造方法（对象创建时执行）

#### 扩展：继承场景下的执行顺序
父类静态代码块 → 子类静态代码块 → 父类实例代码块 → 父类构造方法 → 子类实例代码块 → 子类构造方法

# 内部类
### 一、内部类的核心定义
内部类是定义在**另一个类（外部类）内部**的类，本质是一个独立的类，但与外部类形成了 “逻辑上的包含关系”

核心价值：
- 封装性更强：内部类可以直接访问外部类的所有成员（包括 `private`），但外部类外的其他类无法直接访问内部类；
- 代码更紧凑：把逻辑相关的类放在一起，提升代码可读性和维护性；
- 实现 “多继承” 效果：一个内部类可以继承另一个类 / 实现接口，间接弥补 Java 单继承的限制

### 二、内部类的分类（核心）
根据是否带 `static` 修饰、定义位置，内部类分为 4 类，核心区别如下：

|类型|定义位置|核心特征|访问外部类成员|实例化方式|
|---|---|---|---|---|
|成员内部类（非静态）|外部类的成员位置（和变量 / 方法同级）|无 `static` 修饰，依赖外部类对象|可直接访问外部类的**所有成员**（静态 / 实例）|先创建外部类对象，再创建内部类对象：`外部类.内部类 变量名 = 外部类对象.new 内部类();`|
|静态内部类|外部类的成员位置|有 `static` 修饰，属于外部类本身|只能访问外部类的**静态成员**|直接创建：`外部类.内部类 变量名 = new 外部类.内部类();`|
|局部内部类|外部类的方法 / 代码块内|作用域仅限于当前方法 / 代码块|可访问外部类成员，若访问方法内局部变量，该变量需是 `final`（Java 8+ 隐式 final）|仅在方法内实例化，外部无法访问|
|匿名内部类|外部类的方法 / 代码块内|无类名，一次性使用，本质是局部内部类的简化|同局部内部类|定义时直接实例化：`new 父类/接口() { 重写方法 }`|

### 三、各类内部类的实战示例
#### 1. 成员内部类（非静态内部类）
最基础的内部类，依赖外部类对象存在，可直接访问外部类所有成员
**注意**：
- 成员内部类不能定义静态成员（除了 `static final` 常量）；
- 外部类访问内部类成员，需先创建内部类对象
#### 2. 静态内部类
属于外部类本身，不依赖外部类对象，仅能访问外部类静态成员，是实际开发中最常用的内部类
- 把相关的工具类嵌套在外部类中，避免类名污染（如 `CircleUtil` 仅属于 `MathUtils`）；
- 可定义静态方法，使用更灵活
#### 3. 局部内部类
定义在方法 / 代码块内，作用域仅限于当前方法，外部完全不可见，适用于仅在某个方法内使用的类
**注意**：
- 局部内部类不能用 `public/private/protected/static` 修饰；
- 访问方法内的局部变量时，该变量必须是 `final`（Java 8+ 自动隐式 final，无需手动写，但仍不能重新赋值）
#### 4. 匿名内部类（最常用）
无类名的局部内部类，定义时直接实例化，一次性使用，常用于简化 “仅重写一个 / 几个方法” 的场景（如接口回调、线程创建）
**价值**：
- 省去创建独立类的麻烦，简化代码（尤其是仅使用一次的场景）；
- 是 Lambda 表达式的前身（Java 8+ 可通过 Lambda 进一步简化匿名内部类）
### 注意事项
1. **访问权限**：
    - 成员内部类 / 静态内部类可被 `public/private/protected` 修饰（控制外部类外的访问权限）；
    - 局部内部类 / 匿名内部类不能被访问修饰符修饰
2. **this 关键字**：
    - 内部类中 `this` 代表内部类对象；
    - 访问外部类对象需用 `外部类名.this`（如 `Car.this.brand`）
3. **继承内部类**：
    - 继承成员内部类时，子类构造方法需显式调用外部类对象的内部类构造方法
4. **内存泄漏风险**：
	- 非静态内部类会隐式持有外部类对象的引用，若内部类对象生命周期长于外部类，可能导致外部类无法被 GC 回收，引发内存泄漏（静态内部类无此问题）

# Lambda-函数式编程
- JDK8新增，本质是**简化 “只有一个抽象方法的接口（函数式接口）” 的匿名内部类写法**，可以把它理解为：
> 一段可以传递的代码（代码作为参数），用更简洁的语法替代繁琐的匿名内部类

## Lambda 的使用前提
Lambda 表达式**只能用于函数式接口**（Functional Interface），这是核心前提：
- 函数式接口定义：**只有一个抽象方法**的接口（可以有默认方法、静态方法、私有方法）；
- 标识：可通过 `@FunctionalInterface` 注解标记（可选，但推荐，编译器会校验是否符合函数式接口规则）；
- 常见内置函数式接口：`java.lang.Runnable`、`java.util.function.Consumer`、`java.util.function.Predicate` 等
## 核心语法
###  基础语法
```java
(参数列表) -> { 方法体 }
```
- `()`：参数列表，若只有一个参数，`()` 可省略；若无参数，`()` 必须保留；
- `->`：Lambda 操作符（箭头操作符），分隔参数和方法体；
- `{}`：方法体，若方法体只有一行代码，`{}` 可省略；若有返回值，且只有一行代码，`return` 也可省略
### 方法引用
#### 静态方法引用
- 类名：：静态方法
- Lambda 表达式只是调用一个静态方法，-> 前后参数形式一致，可以使用
```java
Arrays.sort( students , ( o1 , o2 ) -> o1.getAge() - o2.getAge())
Arrays.sort( students , ( o1 , o2 ) -> Student.compareByAge( o1, o2))
Arrays.sort( students , Student::compareByAge )
```
#### 实例方法引用
- 对象名：：实例方法
- Lambda 表达式只是通过对象名调用一个实例方法，-> 前后参数形式一致，可以使用
```java
Student t = new Student()
Arrays.sort( students , ( o1 , o2 ) -> o1.getAge() - o2.getAge())
Arrays.sort( students , ( o1 , o2 ) -> t.compareByAge( o1, o2))
Arrays.sort( students , t::compareByAge )
```
#### 特定类的方法引用
- 特定类的方法名称：：方法
- 调用特定类的实例方法，前面参数列表中第一个参数作为方法的主调，后面所有参数都是作为该实例方法的入参，可以使用
```java
忽略大小写排序
Arrays.sort(name, new Compartor<String>(){
	public int compare(String o1,String p2){
		return o1.compareToIgnoreCase(o2);
	}
})
Arrays.sort(name, ( o1, o2) -> return o1.compareToIgnoreCase(o2))
Arrays.sort(name, String::compareToIgnoreCase)
```
#### 构造器引用
- 类名：：new
- 只是在创建对象，-> 前后参数形式一致，可以使用
```java
CF cf = new CF(){
	public Car getcar(String name){
		return new Car(name)
	}
}
CF cf = name -> new Car(name)
CF cf = Car::new
interface CF{
	Car getcar(String name)
}
class Car{
	private String name
}
```
### 注意事项
1. **变量捕获**：Lambda 中访问的局部变量必须是 `final` 或 “有效 final”（即变量值从未被修改），否则编译报错；
2. **this 指向**：Lambda 中的 `this` 不是 Lambda 本身，而是外部类的对象（与匿名内部类不同）；
3. **异常处理**：若函数式接口的抽象方法声明了异常，Lambda 中可直接抛出；否则需在 Lambda 内捕获异常；
4. **方法引用**：Lambda 可进一步简化为方法引用（如 `System.out::println`），本质是 Lambda 的语法糖，适用于 “方法体仅调用一个已有方法” 的场景

# 抽象类
抽象类是用 `abstract` 关键字修饰的类，本质是**不完整的、不能被实例化的 “模板类”**，核心作用是：

> 抽取多个子类的公共特征（属性 / 方法），定义抽象方法（只有声明、没有实现），强制子类必须实现这些抽象方法，从而约束子类的行为，同时实现代码复用

#### 基础语法
```java
// 抽象类：用 abstract 修饰，不能被实例化
public abstract class 抽象类名 {
    // 1. 普通成员变量（和普通类一致）
    private String name;

    // 2. 普通方法（有实现，子类可直接继承使用）
    public void sleep() {
        System.out.println(name + "在睡觉");
    }

    // 3. 抽象方法：用 abstract 修饰，只有声明，没有方法体（{}）
    public abstract void eat();

    // 4. 构造方法（抽象类有构造方法，用于子类初始化父类成员）
    public 抽象类名(String name) {
        this.name = name;
    }
}

// 子类：必须实现抽象类的所有抽象方法（除非子类也是抽象类）
public class 子类名 extends 抽象类名 {
    // 实现抽象方法（@Override 可选，但推荐）
    @Override
    public void eat() {
        // 具体实现逻辑
    }
}
```
#### 核心规则（必须牢记）

|规则|说明|
|---|---|
|实例化限制|抽象类**不能被实例化**（不能用 `new 抽象类名()`），只能被继承；|
|抽象方法|抽象方法**只有声明，没有方法体**（`{}`），必须用 `abstract` 修饰；<br><br>抽象类中**可以没有抽象方法**（但此时抽象类无意义）；<br><br>有抽象方法的类**必须是抽象类**；|
|子类要求|非抽象子类继承抽象类时，**必须实现所有抽象方法**；<br><br>若子类也是抽象类，则可暂不实现父类的抽象方法；|
|修饰符限制|抽象类 / 抽象方法不能用 `final` 修饰（final 类不能被继承，final 方法不能被重写，与抽象类的 “被继承、被重写” 核心逻辑冲突）；<br><br>抽象方法不能用 `private` 修饰（private 方法无法被子类重写）；<br><br>抽象方法不能用 `static` 修饰（static 方法属于类，不能被重写）；|
|构造方法|抽象类有构造方法（用于子类初始化父类成员），但不能直接调用（因为无法实例化）；|

# 接口
## 概述
接口是 Java 中一种特殊的抽象类型，用 `interface` 关键字定义，本质是**一组 “行为规范 / 契约”**，核心作用是：
> 定义方法声明（what to do），但不关注实现（how to do），强制实现类遵守这组规范，同时弥补 Java 单继承的限制。
#### 基础语法
```java
// 接口定义：用 interface 关键字
public interface 接口名 {
    // 1. 常量：默认 public static final（可省略）
    String VERSION = "1.0"; // 等价于 public static final String VERSION = "1.0";

    // 2. 抽象方法：Java 8 前唯一的方法类型，默认 public abstract（可省略）
    void doSomething(); // 等价于 public abstract void doSomething();

    // 3. 默认方法（Java 8+）：用 default 修饰，有方法体，实现类可继承/重写
    default void defaultMethod() {
        System.out.println("接口默认方法");
    }

    // 4. 静态方法（Java 8+）：用 static 修饰，有方法体，只能通过接口名调用
    static void staticMethod() {
        System.out.println("接口静态方法");
    }

    // 5. 私有方法（Java 9+）：用 private 修饰，有方法体，仅接口内部使用（复用默认方法逻辑）
    private void privateMethod() {
        System.out.println("接口私有方法");
    }
}

// 实现类：用 implements 关键字实现接口，必须实现所有抽象方法
public class 实现类名 implements 接口名 {
    // 实现接口的抽象方法
    @Override
    public void doSomething() {
        // 具体实现逻辑
    }
}

// 多实现：一个类可实现多个接口（弥补单继承）
public class 实现类名 implements 接口1, 接口2 {
    // 实现接口1和接口2的所有抽象方法
}
```
## 注意
 1. 一个接口继承多个接口，
 2. 
 3. 一个类实现了多个接口，存在同名的默认方法，可以不冲突，这个类重写该方法即可
#### 规则（必须牢记）

| 规则    | 说明                                                                                                                                                                                                     |
| ----- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 实例化限制 | 接口**不能被实例化**（不能用 `new 接口名()`），只能被实现；                                                                                                                                                                   |
| 成员变量  | 只能是 `public static final` 常量（默认，无需手动写），声明时必须赋值；                                                                                                                                                        |
| 方法类型  | - 抽象方法：默认 `public abstract`，无方法体，实现类必须实现（除非实现类是抽象类）；<br><br>- 默认方法：`default` 修饰，有方法体，实现类可继承或重写；<br><br>- 静态方法：`static` 修饰，有方法体，只能通过 `接口名.方法名()` 调用，实现类无法重写；<br><br>- 私有方法：`private` 修饰，有方法体，仅接口内部复用逻辑； |
| 继承特性  | - 接口可继承多个接口（用 `extends`）：`interface A extends B, C {}`<br>如果接口中存在方法签名冲突，则此时不支持多继承，也不支持多实现<br>- 继承父类，又实现了接口，如果有同名的默认方法，有限调用父类<br>调用接口的，接口名.super.show() 中转<br><br>- 类只能单继承，但可实现多个接口（核心价值）；              |
| 访问权限  | 接口默认 `public`，抽象方法默认 `public`（实现类重写时不能降低访问权限）；                                                                                                                                                         |
| 构造方法  | 接口**无构造方法**（接口仅定义行为，无实例成员需要初始化）；                                                                                                                                                                       |
|       |                                                                                                                                                                                                        |

# 抽象类 vs 接口

抽象类和接口都是面向对象中 “抽象化” 的工具，容易混淆，核心区别如下（面试高频）：

|特性|抽象类|接口|
|---|---|---|
|关键字|`abstract class`|`interface`|
|继承方式|子类用 `extends` 继承（Java 单继承）|子类用 `implements` 实现（可实现多个）|
|成员变量|可定义任意变量（public/private/static/final）|只能是 `public static final`（默认，可省略）|
|方法类型|可包含普通方法（有实现）、抽象方法|Java 8 前：只能是抽象方法；<br><br>Java 8+：可包含默认方法（`default`）、静态方法；<br><br>Java 9+：可包含私有方法|
|构造方法|有构造方法（用于子类初始化）|无构造方法|
|设计理念|“is-a” 关系（如 Cat is a Animal），强调**继承 / 复用**|“has-a”/“can-do” 关系（如 Runnable 表示 “可运行”），强调**行为约束**|
|使用场景|多个类有**相同的属性和部分相同的方法**，需抽取公共模板|多个类有**相同的行为**，但属性 / 实现完全不同|
# 枚举类
```java
修饰符 enum 枚举类名{
	名称1，名称2.。。。；//只能罗列对象名称
	其他成员
}
```
### 特点
- 第一行只能写枚举类的对象名称，要用逗号隔开
- ==本质是常量，每个变量记住了枚举类的一个对象
- 枚举类都是最终类，不可以被继承，枚举类都是继承 java.lang.Enum 类的
- 构造器私有，对外不能创建对象
- 编译器为枚举类新增方法 name(),ordinal() 索引
### 场景
- 信息分类和标志