# 插入数据
- **insert优化**
	- 批量插入：500-1000
	- 手动提交事务
	- 主键顺序插入
	- 大批量数据插入：load
```mysql
# 客户端连接服务器时，加参数 --local-infile
mysql --local-infile -u root -p
# 设置全局参数local_infile=1，开启从本地加载文件导入数据的开关
select @@local_infile;
set global local_infile = 1;
# 执行load指令将准备好的数据，加载到表结构中
load data local infile '/root/xx' into table 'table_name' fields terminated by ',' lines terminated by '/n';
```
- **主键优化**
	- 数据组织方式
		- InnoDB中，表数据是根据主键顺序组织存放的，这种表称为索引组织表IOT
	- 页分裂--主键乱序插入
		- 页可以为空，填一半，填满。每页包含2-N行数据（数据过大会行溢出），根据主键排列
	- 页合并
		- 当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记(flaged）为删除并且它的空间变得允许被其他记录声明使用。
		- 当页中删除的记录达到MERGE_THRESHOLD（合并页的阈值，默认为页的50%，可在创建表或创建索引时指定），InnODB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。
	- 主键设计原则
		- 满足业务需求情况下，降低主键长度
		- 插入时顺序插入，使用AUTO_INCREMENT自增主键
		- 不使用UUID做主键或其他自然主键
		- 避免对主键修改
- **order by优化**
	1. Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序
	2. Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高
	- 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则
	- 尽量使用覆盖索引
	- 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC)
	- 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)
	- 最左前缀
- **group by优化**
	- 最左前缀
	- 建立适当索引
- **limit优化**
	- 覆盖索引+子查询：
	- id覆盖索引搜索，数据使用返回id进行聚集索引搜索
- **count优化**
	- MyISAM把表的总行数存在磁盘上，count会直接返回，效率高
	- 自己计数
	- count()是聚合函数，对于返回数据一行行判断，非NULL加1，最后返回累计
	- 用法
		- count(*)*：直接按行累加
		- count(主键)：把每行的主键返回给服务层，直接累加
		- count(字段)
			- 没有not null约束：每行字段值提取，返回服务层，判断不为null，累加
			- 有not null约束：每行字段值提取，返回服务层，累加
		- count(1)：遍历不取值，返回每行，放数字，直接按行累加
- **update优化**
	- 没有字段的索引，表锁
	- 根据索引更新，索引不能失效