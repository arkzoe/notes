- 线程，程序内的一条执行流程
- 多线程，软硬件上实现多条执行流程，CPU执行
## 创建方式
### 继承Thread类，重写run，strat启动
```java
Thread mt = new mythread();
mt.start();
class mythread extends Thread {
	public void run(){
		//线程任务
		//子线程
	}
}
```
main方法由一条主线程执行
- 优：编码简单
- 缺：继承Thread，无法继承其他类，不利于拓展
==注：==
1. 启动调start，不是run
	- run会当成普通方法
2. 不能把主线程放在启动子线程之前
### 实现Ruannable接口,重写run
```java
Runnable r = new myrunnable();
//线程任务对象包装成线程对象
Thread t = new Thread(r);
t.start();
class myrunnable implements Runnable {
	public void run(){
		
	}
}
```
- 优：可拓展
- 缺：需要多一个Runnable对象
#### 匿名内部类写法
```java
Runnable r = new Runnable(){
	public void run(){
		
	}
};
//线程任务对象包装成线程对象
Thread t = new Thread(r);
t.start();

new Thread(new Runnable(){
	public void run(){
		
	}
}).start();

new Thread(()->{

}).start();
```
### 实现Callable接口
- 前两种问题--不能直接返回数据
- JDK5，提供Callable接口和FutureTask类
	- 可返回结果
1. 创建任务对象
	1. 定义类实现Callable接口，实现call方法，封装要做的事，和要返回的数据
	2. 把Callable类型对象封装成FutureTask（线程任务对象）
2. 线程任务对象交给Thread对象
3. 调用Thread对象的start方法
4. 执行完毕后，通过FutureTask对象的get方法获取结果
```java
Callable<V> cl = new MyCallable();
//本质Runnable线程任务对象
//获取线程执行完的结果
FutureTask<V> f1 = new FutureTask(cl);
Thread t1 = new Thread(f1);
t1.start();
try{
	//发现线程没有执行完毕，会让出CPU，等执行完毕继续
	System.out.println(f1.get());
}catch(Exception e){
	e.printStackTrace();
}

class myucallable implements callable<V>{
	public V call() throw Exception{
		return ;
	}
}
```
- 优：拓展性强，线程执行完毕能获取值
- 缺：编码复杂
## 常用方法

| Thread方法                                    |                            |
| ------------------------------------------- | -------------------------- |
| public void run()                           | 线程的任务方法                    |
| public void start()                         | 启动线程                       |
| public String getName()                     | 获取当前线程的名称，线程名称默认是Thread-索引 |
| public void setName(String name)            | 为线程设置名称                    |
| public static Thread currentThread()        | 获取当前执行的线程对象                |
| public static void sleep(long time)         | 让当前执行的线程休眠多少毫秒后，再继续执行      |
| public final void join()...                 | 让调用当前这个方法的线程先执行完！          |
|                                             |                            |
| 常见构造器                                       |                            |
| public Thread(String name)                  | 可以为当前线程指定名称                |
| public Thread(Runnable target)              | 封装Runnable对象成为线程对象         |
| public Thread(Runnable target, String name) | 封装Runnable对象成为线程对象，并指定线程名称 |

## 线程安全
- 多线程共同操作一个共享资源时，存在修改出现业务安全问题
## 线程同步
- 加锁：每次只允许一个线程加锁，加锁才能访问，访问完解锁
### 同步代码块
- 把访问共享资源的核心代码上锁
```java
synchronized(this(同步锁--唯一对象)){

}
```
- 注：对于同时执行的线程，同步锁必须是同一把（同一对象）
- 共享资源作为锁对象，实例方法用this
- 静态用字节码（类名.class）作为锁对象
### 同步方法
- 把访问共享资源的核心方法上锁
```java
修饰符 synchronized 返回值类型 方法名(形参){

}
```
- 底层隐式锁对象，锁的是整个方法代码
- 方法是实例方法：同步方法默认用this作为锁对象
### Lock锁
- JDK5提供，创建锁对象进行加锁和解锁
- Lock是接口，用实现类ReentrantLock构建锁对象
```java
void lock();
void unlock();

private final Lock lk = new ReentrantLock();//保护锁对象
//unlock放finally里
```
## 线程池
- 复用线程的技术
- JDk5提供，线程池接口：ExecutorService
### 实现类ThreadPoolExecutor创建线程池
![[ThreadPoolExecutor.png]]
### 处理任务

| 方法                                   |                                   |
| ------------------------------------ | --------------------------------- |
| void execute(Runnable command)       | 执行Runnable任务                      |
| Future< T> submit(Callable< T> task) | 执行Callable任务，返回未来任务对象，用于获取线程返回的结果 |
| void shutdown()                      | 等全部任务执行完毕后，再关闭线程池！                |
| List< Runnable> shutdownNow()        | 立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务    |

- 一般不关线程池
==临时线程创建时机：==
1. 有定义临时线程的名额
2. 核心线程都在工作
3. 任务队列满员
4. 有新任务尝试加入任务队列
==拒绝==
5. 核心线程、临时线程都在工作
6. 任务队列满员
7. 有新任务尝试加入任务队列

| 策略                                        |                                            |
| ----------------------------------------- | ------------------------------------------ |
| ThreadPoolExecutor.AbortPolicy()          | 丢弃任务并抛出RejectedExecutionException异常是默认的策略 |
| ThreadPoolExecutor. DiscardPolicy()       | 丢弃任务，但是不抛出异常，这是不推荐的做法                      |
| ThreadPoolExecutor. DiscardOldestPolicy() | 抛弃队列中等待最久的任务然后把当前任务加入队列中                   |
| ThreadPoolExecutor. CallerRunsPolicy()    | 由主线程负责调用任务的run（）方法从而绕过线程池直接执行              |

### Executors工具类创建

| 方法名称                                                                            |                                               |
| ------------------------------------------------------------------------------- | --------------------------------------------- |
| public static ExecutorService newFixedThreadPool(int nThreads)                  | 创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它 |
| public static ExecutorService newSingleThreadExecutor()                         | 创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程     |
| public static ExecutorService newCachedThreadPool()                             | 线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了60s则会被回收掉         |
| public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) | 创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务              |

- 大型并发系统环境中使用Excutors可能出现系统风险
### 并发/并行
- 正在运行的程序（软件）就是一个独立的进程
- 线程属于进程，一个程序中能同时运行多个线程
- ==进程中多个线程是并发和并行执行的==
- **并发(Concurrency)**：
    - 指多个任务**交替执行**，在单核CPU上通过时间片轮转实现    
    - 在宏观上看起来像是同时执行，但微观上是轮流执行
    - 关注的是任务处理的**结构**和**组织方式**
- **并行(Parallelism)**：
    - 指多个任务**真正同时执行**，需要多核/多CPU支持
    - 在宏观和微观上都是同时执行
    - 关注的是任务执行的**效率**和**速度提升**