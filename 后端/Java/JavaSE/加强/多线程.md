- 线程，程序内的一条执行流程
- 多线程，软硬件上实现多条执行流程，CPU执行
## 创建方式
### 继承Thread类，重写run，strat启动
```java
Thread mt = new mythread();
mt.start();
class mythread extends Thread {
	public void run(){
		//线程任务
		//子线程
	}
}
```
main方法由一条主线程执行
- 优：编码简单
- 缺：继承Thread，无法继承其他类，不利于拓展
==注：==
1. 启动调start，不是run
	- run会当成普通方法
2. 不能把主线程放在启动子线程之前
### 实现Ruannable接口,重写run
```java
Runnable r = new myrunnable();
//线程任务对象包装成线程对象
Thread t = new Thread(r);
t.start();
class myrunnable implements Runnable {
	public void run(){
		
	}
}
```
- 优：可拓展
- 缺：需要多一个Runnable对象
#### 匿名内部类写法
```java
Runnable r = new Runnable(){
	public void run(){
		
	}
};
//线程任务对象包装成线程对象
Thread t = new Thread(r);
t.start();

new Thread(new Runnable(){
	public void run(){
		
	}
}).start();

new Thread(()->{

}).start();
```
### 实现Callable接口
- 前两种问题--不能直接返回数据
- JDK5，提供Callable接口和FutureTask类
	- 可返回结果
1. 创建任务对象
	1. 定义类实现Callable接口，实现call方法，封装要做的事，和要返回的数据
	2. 把Callable类型对象封装成FutureTask（线程任务对象）
2. 线程任务对象交给Thread对象
3. 调用Thread对象的start方法
4. 执行完毕后，通过FutureTask对象的get方法获取结果
```java
Callable<V> cl = new MyCallable();
//本质Runnable线程任务对象
//获取线程执行完的结果
FutureTask<V> f1 = new FutureTask(cl);
Thread t1 = new Thread(f1);
t1.start();
try{
	//发现线程没有执行完毕，会让出CPU，等执行完毕继续
	System.out.println(f1.get());
}catch(Exception e){
	e.printStackTrace();
}

class myucallable implements callable<V>{
	public V call() throw Exception{
		return ;
	}
}
```
- 优：拓展性强，线程执行完毕能获取值
- 缺：编码复杂
## 常用方法
![[Thread.png]]
## 线程安全
- 多线程共同操作一个共享资源时，存在修改出现业务安全问题
## 线程同步
- 加锁：每次只允许一个线程加锁，加锁才能访问，访问完解锁
### 同步代码块
- 把访问共享资源的核心代码上锁
```java
synchronized(this(同步锁--唯一对象)){

}
```
- 注：对于同时执行的线程，同步锁必须是同一把（同一对象）
- 共享资源作为锁对象，实例方法用this
- 静态用字节码（类名.class）作为锁对象
### 同步方法
- 把访问共享资源的核心方法上锁
```java
修饰符 synchronized 返回值类型 方法名(形参){

}
```
- 底层隐式锁对象，锁的是整个方法代码
- 方法是实例方法：同步方法默认用this作为锁对象
### Lock锁
- JDK5提供，创建锁对象进行加锁和解锁
- Lock是接口，用实现类ReentrantLock构建锁对象
```java
void lock();
void unlock();

private final Lock lk = new ReentrantLock();//保护锁对象
//unlock放finally里
```
## 线程池
- 复用线程的技术
- JDk5提供，线程池接口：ExecutorService
### 实现类ThreadPoolExecutor创建线程池
![[ThreadPoolExecutor.png]]
### 处理任务
![[ExecutorService常用方法.png]]
- 一般不关线程池
==临时线程创建时机：==
1. 有定义临时线程的名额
2. 核心线程都在工作
3. 任务队列满员
4. 有新任务尝试加入任务队列
==拒绝==
5. 核心线程、临时线程都在工作
6. 任务队列满员
7. 有新任务尝试加入任务队列
![[任务拒绝策略.png]]
### Executors工具类创建
![[Executors创建线程池.png]]
- 大型并发系统环境中使用Excutors可能出现系统风险
### 并发/并行
- 正在运行的程序（软件）就是一个独立的进程
- 线程属于进程，一个程序中能同时运行多个线程
- ==进程中多个线程是并发和并行执行的==
- **并发(Concurrency)**：
    - 指多个任务**交替执行**，在单核CPU上通过时间片轮转实现    
    - 在宏观上看起来像是同时执行，但微观上是轮流执行
    - 关注的是任务处理的**结构**和**组织方式**
- **并行(Parallelism)**：
    - 指多个任务**真正同时执行**，需要多核/多CPU支持
    - 在宏观和微观上都是同时执行
    - 关注的是任务执行的**效率**和**速度提升**