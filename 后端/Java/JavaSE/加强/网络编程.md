## 基本通讯架构
- CS架构（Client客户端/Server服务端）、BS架构（Brower浏览器/Server服务端）
![[CS架构.png]]![[BS架构.png]]
## 网络编程三要素
### IP
- 设备在网络中的地址，是设备唯一标识
- 互联网协议地址
#### IPv4
- 32位，点分十进制
#### IPv6
- 128位，冒分十六进制
#### IP域名
- 识别定位网站的人类可读的名称
#### DNS域名解析
- 将人类可读的域名转换为机器可读的IP地址
#### 公网IP、内网IP
公网IP：可以连接到互联网的IP地址
内网IP：局域网IP，只能组织机构内部使用的IP地址
##### 本机IP
127.0.0.1、localhost：只会寻找当前程序所在的主机
##### 常用命令
ipconfig：查看本机IP地址
ping IP地址：检查网络是否连接
#### InetAddress
![[InetAddress.png]]
### 端口
- 应用程序在设备中唯一标识
- 16位二进制
#### 分类
周知端口：0~1023，被预先定义的知名应用占用
注册端口：1024~49151，分配给用户进程或应用程序
动态端口：46152~65535，不固定分配，动态分配
注：一般选择注册端口，同一设备中不能出现两个程序端口号一样
### 协议
- 连接和数据在网络中传输的规则
- OSi网络参考模型：全球网络互联标准
- TCP/IP网络模型：实际上的国际标准
![[网络协议.png]]
#### UDP
通信效率高--视频直播--语音通话
- 用户数据报协议
- 特点：无连接、不可靠通信
- 不事先建立联系，数据按包发送，一包包含：自己的IP、端口、目的地IP、端口和数据（64kb内）等
- 不管对方是否在线，丢失也不管，接受到数据也不返回确认，不可靠
#### TCP
通信效率相对不高-可靠性高--网页、文件下载、支付
特点：面向连接、可靠通信
目的：保证在不可靠的信道上实现可靠的数据传输
三个步骤：
- 三次握手建立连接：确保通信双方收发消息都没问题
- 传输数据进行确认
- 四次挥手断开连接：确保收发消息都已经完成
## UDP通信
- java.net.DatagramSocket类
![[UDP通信.png]]
```java
//客户端
//创建发送端对象
DatagramSocket socket = new DatagramSocket();
//创建数据包对象封装要发送的数据
byte[] bytes = "".getBytes();
/*
1.发送的数据
2.字节长度
3.目的地IP
4.端口
*/
DatagramPacket packet = new DatagramPacket(bytes,bytes.length,InetAddress.get,8080)；
//发送
socket.send(packet);
//关闭
socket.close();

//服务端
//创建接受端对象，注册端口
DatagramSocket socket = new DatagramSocket(8080);
//创建接受对象
bytes[] buf = new byte[1024*64];
DaagramPacket packet = new DatagramPacket(buf,buf.length);
//接受数据
socket.receive(packet);
//看是否接收
int len = packet.getLength();
String data = new String (buf,0,len);
print
//获取对方IP
String ip = packet.getAddress().getHostAddress();
int port = packet.getPort();
print
//关闭
socket.close();
```
## TCP通信
- java.net.Socket类
![[TCP通信.png]]
```java
//客户端
//创建Socket管道对象，请求服务器Socket连接
Socket socket = new Socket(host,port);
//从管道中得到一个字节输出流
OutputStream os = socket.getOutputStream();
//特殊数据
DataOutputStream dos = new DataOutputStream(os);
dos.write();

//关闭
socket.close();
```
![[TCP服务端.png]]
```java
//创建服务端对象，绑定端口号
ServerSocket ss = new  ServerSocket(port);
//调accept方法，等待客户端连接，有客户端连接返回Socket对象
Socket socket = ss.accept();
//获取输入流，读取客户端发送的数据
InputStream is = socket.getInputStream();
//字节输入流包装成特殊输入流
DataInputStream dis = new DataInputStream(is);
//读数据
xx x = dis.read();
print
//客户端ip
System.out.println("客户端ip"+socket.getAddress().getHostAddress());
System.out.println("客户端ip"+socket.getPort());
```
### 同时接受多个客户端消息
- 主线程：负责客户端连接
```java
public static void main(){
	ServerSocket ss = new  ServerSocket(port);
	while(true){
		Socket socket = ss.accept();
		System.out.println("客户端上线"+socket.getAddress().getHostAddress());
		//独立子线程专门负责接收
		new SeverReader(socket).start();
	}
}
public class ServerReader extends Thread{
	private Socket socket;
	public ServerReader(Socket socket){
		this.socket = socket;
	}
	public void run(){
		try{
			InputStream is = socket.getInputStream();
			//字节输入流包装成特殊输入流
			DataInputStream dis = new DataInputStream(is);
			while(true){
				//读数据
				xx x = dis.read();
				System.out.println(x);
				//客户端ip
				System.out.println("客户端ip"+socket.getAddress().getHostAddress());
				System.out.println("客户端ip"+socket.getPort());
			}
		}catch(Exception e){
			e.printStackTrace();
			System.out.println("客户端下线"+socket.getAddress().getHostAddress());
		}
	}
}
```
## B/S架构原理
- http://服务器IP:服务器端口
- 服务器必须给浏览器响应HTTP协议规定的数据格式，否则浏览器不识别
- 线程池优化
![[HTTP协议规定.png]]
```java
public static void main(){
	ServerSocket ss = new  ServerSocket(8080);
	ExecutorService pool = new ThreadPoolExecutor(3,10,10,TimeUnit.SECONDS,new ArrayBlockingQueue<>(100),Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());
	while(true){
		Socket socket = ss.accept();
		System.out.println("客户端上线"+socket.getAddress().getHostAddress());
		//独立子线程专门负责接收
		//new SeverReader(socket).start();
		pool.execute(new ServerReader(socket));
	}
}
public class ServerReader extends Thread{
	private Socket socket;
	public ServerReader(Socket socket){
		this.socket = socket;
	}
	public void run(){
		try{
			//响应网页
			OutputStream os = socket.getOutputStream();
			//字节输出流包装成打印流
			PrintStream ps = new PrintStream(os);
			ps.println("HTTP/1.1 200 OK");
			ps.println("Content-Type:text/html;charset=utf-8");
			ps.println();
			ps.println("xxxxx");
			ps.close();
			socket.close();
		}catch(Exception e){
			e.printStackTrace();
			System.out.println("客户端下线"+socket.getAddress().getHostAddress());
		}
	}
}
```