- 高效获取数据的数据结构--有序
- 优：
	- 提高数据检索效率，降低IO成本
	- 降低排序成本，CPU消耗
- 缺：
	- 索引列占空间
	- 提升查询效率，降低更新速度
# 结构
- 存储引擎层实现
- B+Tree索引：常见，大部分都支持
- Hash索引：用哈希表实现，精确匹配索引列才有效，不支持范围查询
- R-tree（空间索引）：MyISAM，用于地理空间数据类型
- Full-text（全文索引）：建立倒排索引，快速匹配文档的方式。类似Lucene,Solr.ES
![[索引支持.png]]

### B 树
- **结构特点**：  
    一种`m`阶多路树（每个节点可包含多个关键字和子节点）。
    - 每个节点最多有`m-1`个关键字，按升序排列，对应`m`个子节点（关键字划分了子节点的范围）。
    - 非根节点至少有`⌈m/2⌉-1`个关键字（保证节点不过空），根节点至少 1 个关键字。
    - 所有叶子节点在同一层，保证查询路径长度一致（平衡性）。
- **核心特性**：  
    非叶子节点既存储索引（关键字）也存储实际数据，查询时找到关键字即可获取数据。
### B + 树
B + 树是 B 树的变体，优化了范围查询能力，是数据库索引的主流选择。
- **结构特点**：  
    保留 B 树的多路性和平衡性，但有关键差异：
    - **非叶子节点仅作索引**：不存储实际数据，只保存关键字用于指引查询方向。
    - **叶子节点存储全部数据**：所有关键字和对应数据都在叶子节点，且叶子节点通过链表按顺序连接。
- **核心优势**：
    1. 范围查询高效：通过叶子节点的链表可快速遍历连续数据（如`WHERE id BETWEEN 100 AND 200`）。
    2. 非叶子节点存储更多索引：相同空间下，B + 树的非叶子节点能容纳更多关键字，减少树的高度，降低 I/O 次数。
### Hash
- 用hash算法将键值转换成新的hash值，映射到对应槽位，存于哈希表中
- 只能用于对等比较
- 无法利用索引完成排序操作
- 查询效率高，同常一次
- InnoDB自适应hash
# 分类
- 功能分类
![[分类.png]]
- 存储形式分类
![[存储形式分类.png]]
- 存在主键，主键就是聚集索引
- 不存在，使用第一个唯一索引为聚集索引
- 回表查询：先走二级索引获取主键值，再到聚集索引拿到行数据
# 语法
```mysql
--创建索引
CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name,...);
--查看索引
SHOW INDEX FROM table_name;
--删除索引
DROP INDEX index_name ON table_name;
```
# SQL性能分析
- **SQL执行频率**
```mysql
show [session|global] status like 'Com_______';
--查询为主优化
```
- **慢查询日志**--定位效率低
```mysql
SHOW VARIABLES LIKE 'slow_query_log';
SHOW VARIABLES LIKE 'slow_query_log_file';//路径
SHOW VARIABLES LIKE 'long_query_time';//阈值
# 开启慢日志查询开关
slow_query_log=1
# 设置慢日志时间为2秒，超过视为慢查询
long_query_time=2
```
- **profile详情**
```mysql
select @@have_profiling;//是否支持
select @@profiling;
set profiling = 1;
# 查询每一条sql耗时
show profiles;
# 查看指定query_id的sql语句各个阶段的耗时情况
show profile for query query_id;
# 查看指定query_id的sql语句cpu使用情况
show profile cpu for query query_id;
```
- **explain执行计划**
```mysql
# 直接在select语句前加explain/desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
```
- 字段
1. **id**
    - 查询标识符，表示 SELECT 语句的执行顺序
    - id 相同表示执行顺序从上到下，id 不同则数值大的先执行
2. **select_type**
    - 查询类型，常见值：
        - SIMPLE：简单查询（不包含子查询或 UNION）
        - PRIMARY：主查询（包含子查询时的外层查询）
        - SUBQUERY：子查询
        - DERIVED：派生表（FROM 子句中的子查询）
        - UNION：UNION 中的第二个或后续查询
        - UNION RESULT：UNION 的结果
3. ==**type**==
	- 访问类型，性能从好到坏排序：
		- NULL：不访问任何表
		- system：表只有一行记录（系统表）
		- const：通过主键或唯一索引一次就找到
		- eq_ref：联表查询时使用主键或唯一索引
		- ref：使用非唯一索引查找
		- range：索引范围扫描
		- index：全索引扫描
		- ALL：全表扫描
4. **==possible_keys==**
    - 可能使用的索引
    - 列出查询可能使用的所有索引
5. **==key==**
    - 实际使用的索引
    - 如果为 NULL，则表示没有使用索引
6. **==key_len==**
    - 使用的索引长度（字节数）
    - 可以判断使用了索引的哪些部分
7. **==rows==**
    - MySQL 估计需要检查的行数
    - 值越小越好
8. **filtered**
    - 存储引擎返回的数据在服务器层过滤后剩余的比例
    - 百分比值，100 表示没有过滤，越大越好
9. **==Extra==**
    - 额外信息，常见值：
        - Using index：使用覆盖索引
        - Using where：使用 WHERE 条件过滤
        - Using temporary：使用临时表
        - Using filesort：使用文件排序
        - Using join buffer：使用连接缓冲
# 使用原则
- **最左前缀法则**：查询从索引最左列开始，不跳过索引中的列
	- 索引使用多列（联合索引）需遵守
	- 跳过某一列，==索引将部分失效（后面字段索引失效）==
	- 字段存在即可，位置无影响
- **范围查询**
	- 联合索引中，出现范围查询（>,<），==范围查询右侧列索引失效==
	- 加=避免
- **索引失效**
	- 索引列运算
		- 不要在索引列上进行运算操作，索引将失效
	- 字符串不加引号
		- 字符串类型使用时，不加引号
	- 模糊查询
		- 头部模糊匹配，失效，尾部不会
	- or连接的条件
		- or前的条件中的列有索引，后面的列没有索引，涉及到的索引都不会用
		- 对于没有索引的创建
	- 数据分布影响
		- MySQL评估使用索引比全表慢，不使用索引
- **SQL提示**
	- 加入人为的提示
	- use index()：使用索引
	- ignore index()：不用
	- force index()：一定用
- **覆盖索引**
	- 尽量使用（查询使用索引，需要返回的列，在该索引中以全部能找到），减少select*
	- using index condition：查找使用索引，需回表查询
	- using where:uisng index：使用索引，但需要的数据都在索引列中能找到，不需回表
- **前缀索引**
	- 当字段类型为字符串(varchar，text等）时，有时候需要索引很长的字符串，这会让索引变大，影响查询效率。此时可以只将字符串的一部分前缀，建立索引
	- 前缀长度：根据索引的选择性决定，选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的
```mysql
create index idx_xxx on table_name(cloumn(n));//n代表前n个字符
select count(distinct xxx) from table_name;//求取不重复字段数
select count(distinct xxx)/count(*) from table_name;//比值
select count(distinct substring(xxx,1,n))/count(*) from table_name;//n个前缀，一般5-10个
```
- **单列索引与联合索引**
	- 如果存在多个查询条件，考虑针对于查询字段建立索引，优先联合索引
	- 多条件联合，MySQL会自己选择
# 设计原则
1. 针对于数据量较大，且查询比较频繁的表建立索引
2. 针对于常作为查询条件(where)、排序(order by)、分组（group by）操作的字段建立索引
3.  尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高
4. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率
7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询