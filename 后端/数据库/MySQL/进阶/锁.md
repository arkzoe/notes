# 全局锁
- 全局锁就是对整个数据库实例加锁,加锁后整个实例就处于只读状态,后续的DML的写语句,DDL语句,已经更新操作的事务提交语句都将被阻塞
- 其典型的使用场景是做全库的逻辑备份,对所有的表进行锁定,从而获取一致性视图,保证数据的完整性
```mysql
flush tables with read lock;
//cmd命令行
mysqldump -uroot -p111 数据库名 > 目录;
unlock tables;
```
1. 如果在主库上备份,那么在备份期间都不能执行更新,业务基本上停摆
2. 如果在从库上备份,那么在备份期间从库不能执行主库同步过来的二进制日志(binlog),会导致主从延迟
- 在InnoDB引擎中,我们可以在备份时加上参数 -- single-transaction参数来完成不加锁的一致性数据备份
# 表级锁
- 每次操作锁住整张表。锁定颗粒度大，发生锁冲突概率最高，并发度最低。大部分支持
- **表锁**
	- 表共享读锁：read lock
		- 只能读，不能写
	- 表独占写锁：write lock
		- 当前客户端可读写，其他不能
```mysql
--加锁
lock tables 表名... read/write;
--释放锁
unlock tables/客户端断开连接
```
- **元数据锁**
	- MDL加锁过程是系统自动控制,无需显式使用,在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性,在表上有活动事务的时候,不可以对元数据进行写入操作
	- 避免DML和DDL冲突
	- 增删改查，加MDL读锁，修改表结构，加MDL写锁

| SQL                                      | 锁类型                                 |                                       |
| ---------------------------------------- | ----------------------------------- | ------------------------------------- |
| lock tables xxx read/write               | SHARE_READ_ONLY/SHARE_NO_READ_WRITE |                                       |
| select、select...lock in share mode       | SHARE_READ                          | SHARE_READ、SHARE_WRITE兼容，与EXCLUSIVE互斥 |
| insert、update、delete、select...for update | SHARE_WRITE                         | SHARE_READ、SHARE_WRITE兼容，与EXCLUSIVE互斥 |
| alter table...                           | EXCLUSIVE--排他锁                      | 与其他MDL互斥                              |
```mysql
--查询元数据锁
select object_type, object_schema, object_name, lock_type, lock_duration from performance schema.metadata_locks ;
```
- **意向锁**
	- 为了避免DML在执行时,加的行锁与表锁的冲突,在InnoDB中引入了意向锁,使得表锁不用检查每行数据是否加锁,使用意向锁来减少表锁的检查
	- 意向共享锁（IS）：select...lock in share mode
		- 与表锁共享锁（read）兼容，与表锁排他锁（write）互斥
	- 意向排他锁（IX）：insert、update、delete、select...for update添加
		- 与表锁共享锁（read），排他锁（write）互斥，意向锁之间不互斥
```mysql
--查询意向锁/行锁
select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;
```
# 行级锁
- 每次操作锁住对应的行数据。锁定颗粒度最小，发生锁冲突概率最低，并发度最高，InnoDB
- InnoDB数据基于索引组织，行锁是通过对索引上的索引项加锁实现
- **行锁**（Record Lock）
	- 锁定单个行记录的锁，防止其他事务对此进行update和delete。在RC、RR隔离级别下都支持
	- 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁
	- 排他锁（X）：允许获取排他锁的事务更新数据，组织其他事务获得相同数据集的共享锁和排他锁

| 当前\请求 | S   | X   |
| ----- | --- | --- |
| S     | 兼容  | 冲突  |
| X     | 冲突  | 冲突  |

| SQL                         | 类型  |                               |
| --------------------------- | --- | ----------------------------- |
| INSERT...                   | 排他  | 自动加锁                          |
| UPDATE...                   | 排他  | 自动加锁                          |
| DELETE...                   | 排他  | 自动加锁                          |
| SELECT（正常）                  | 不加锁 |                               |
| SELECT...LOCK IN SHARE MODE | 共享  | 手动在SELECT后加LOCK IN SHARE MODE |
| SELECT...FOR UPDATE         | 排他  | 手动在SELECT后加FOR UPDATE         |

- **间隙锁**（Gap Lock）
	- 锁定记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在间隙中进行insert，产生幻读，RR隔离级别下支持
- **临键锁**（Next-Key Lock）
	- 行锁和间隙锁组合，同时锁住数据和前面的间隙Gap，RR隔离级别下支持
默认情况下,InnoDB在REPEATABLE READ事务隔离级别运行,InnoDB使用next-key锁进行搜索和索引扫描,以防止幻读
- 行锁
	1. 针对唯一索引进行检索时,对已存在的记录进行等值匹配时,将会自动优化为行锁
	2. InnoDB的行锁是针对于索引加的锁,不通过索引条件检索数据,那么InnoDB将对表中的所有记录加锁,此时就会==升级为表锁==
- 间隙锁&临键锁
	1. 索引上的等值查询(唯一索引)，给不存在的记录加锁时，优化为间隙锁
	2. 索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁
	3. 索引上的范围查询(唯一索引) -- 会访问到不满足条件的第一个值为止
	- 注：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会组织另一个事务在同一间隙上使用间隙锁